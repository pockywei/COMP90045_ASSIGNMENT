============================================
vis/bingfengl.out
02:18:34_Monday_11_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  bingfengl

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc bean_parse.mly
1 rule never reduced
1 shift/reduce conflict.
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
90 states, 5239 transitions, table size 21496 bytes
ocamlopt  -g -c bean_lex.ml
ocamlc  -c bean_pprint.mli
ocamlopt  -g -c bean_pprint.ml
ocamlopt  -g -c bean.ml
ocamlopt -g -o bean bean_ast.cmx bean_lex.cmx bean_parse.cmx bean_pprint.cmx bean.cmx

--- Succeeded ---

******************************************   Parsing lex01.bean:

Syntax error
Mismatch:
1,7c1
< 
< proc main()
<     int x;
< 
<     x := 2 + 1 - 1 * 1;
<     write x;
< end
---
> fname => ../data/lex01.bean

******************************************   Parsing lex02.bean:

Syntax error
Mismatch:
1,11c1
< 
< proc main()
<     int x;
<     int y;
<     int z;
< 
<     read y;
<     x := y + 1;
<     z := x * x + y * y;
<     write z - 1;
< end
---
> fname => ../data/lex02.bean

******************************************   Parsing lex03.bean:

Syntax error
Mismatch:
1,10c1
< 
< proc main()
<     int x;
<     int y;
<     int z;
< 
<     while 42 >= 42 do
<         x := 42;
<     od
< end
---
> fname => ../data/lex03.bean

******************************************   Parsing lex04.bean:

Syntax error
Mismatch:
1,7c1
< typedef {a : int, b : int, c : bool} record
< 
< proc main()
<     record r;
< 
<     r.c := false;
< end
---
> fname => ../data/lex04.bean

******************************************   Parsing syn01.bean:

Syntax error
Mismatch:
1,8c1
< 
< proc main()
<     int x;
< 
<     read x;
<     write (1 * (2 - 3) + 4 - 3) * 2 * -1;
<     write -1;
< end
---
> fname => ../data/syn01.bean

******************************************   Parsing syn02.bean:

Syntax error
Mismatch:
1,6c1
< typedef int float
< 
< proc abc(val bool t, val float t', val int t'')
< 
<     t := true;
< end
---
> fname => ../data/syn02.bean

******************************************   Parsing prpr1.bean:

Syntax error
Mismatch:
1,23c1
< 
< proc main()
<     bool a;
<     int m;
<     int n;
< 
<     p(a);
<     m := n;
<     p(a);
<     n := m + 9 - 1;
<     p(a);
<     if m = m then
<         p(a);
<     else
<         p(a);
<     fi
<     if n = m then
<         p(a);
<         n := m + 1;
<     else
<         p(a);
<     fi
< end
---
> fname => ../data/prpr1.bean

******************************************   Parsing prpr2.bean:

Syntax error
Mismatch:
1,8c1
< 
< proc main()
<     int x;
< 
<     x := -5 + 6;
<     x := -(5 - 2 - 1);
<     x := true and true or true and false;
< end
---
> fname => ../data/prpr2.bean

******************************************   Parsing prpr3.bean:

Syntax error
Mismatch:
1,6c1
< 
< proc main()
<     int x;
< 
<     x := 6 + 3 * 2 + 4 * 5;
< end
---
> fname => ../data/prpr3.bean

******************************************   Parsing prpr4.bean:

Syntax error
Mismatch:
1,21c1
< 
< proc main()
<     int m;
<     int n;
< 
<     read n;
<     while n > 1 do
<         m := n;
<         while m > 0 do
<             if m > 0 then
<                 n := n - 1;
<                 m := m - 1;
<                 if m > 0 then
<                     m := m - 1;
<                 else
<                     n := 6 * n + 4;
<                 fi
<             fi
<         od
<     od
< end
---
> fname => ../data/prpr4.bean

******************************************   Parsing prpr5.bean:

Syntax error
Mismatch:
1,43c1
< 
< proc main()
<     bool x;
< 
<     x := false;
<     p(x, x);
<     if x then
<         if x then
<             p(x, x);
<             if x then
<                 p(x, x);
<             else
<                 p(x, x);
<             fi
<         else
<             if x then
<                 p(x, x);
<             else
<                 while x do
<                     p(x, x);
<                     p(x, x);
<                 od
<                 p(x, x);
<             fi
<             p(x, x);
<         fi
<     else
<         while x do
<             p(x, x);
<             p(x, x);
<         od
<         if x then
<             p(x, x);
<         else
<             p(x, x);
<         fi
<     fi
< end
< 
< proc p(val int u, val int v)
< 
<     write u + v;
< end
---
> fname => ../data/prpr5.bean

******************************************   Parsing prpr6.bean:

Syntax error
Mismatch:
1,41c1
< 
< proc main()
< 
<     p(4);
< end
< 
< proc p()
<     int m;
<     int n;
<     int diff;
< 
<     read m;
<     read n;
<     while m != n do
<         diff := 0;
<         while m * n > 0 do
<             m := m - 1;
<             n := n - 1;
<             diff := diff + 1;
<         od
<         if m != 0 then
<             n := diff;
<         else
<             m := diff;
<         fi
<     od
<     write m;
< end
< 
< proc q()
<     bool x;
< 
<     x := true and true or true and false;
< end
< 
< proc r()
<     int x;
< 
<     x := 6;
<     s(x, x);
< end
---
> fname => ../data/prpr6.bean

******************************************   Parsing bell.bean:

Syntax error
Mismatch:
1,29c1
< 
< proc main()
<     int n;
<     int result;
< 
<     write "Type integer n: ";
<     read n;
<     bell(n, 0, result);
<     write "Bell(n) is: ";
<     write result;
<     write "\n";
< end
< 
< proc bell(val int n, val int m, ref int out)
<     int resA;
<     int resB;
< 
<     if m = 0 then
<         if n = 0 then
<             out := 1;
<         else
<             bell(n - 1, n - 1, out);
<         fi
<     else
<         bell(n, m - 1, resA);
<         bell(n - 1, m - 1, resB);
<         out := resA + resB;
<     fi
< end
---
> fname => ../data/bell.bean

******************************************   Parsing fib.bean:

Syntax error
Mismatch:
1,24c1
< 
< proc main()
<     int n;
<     int m;
< 
<     write ">";
<     read n;
<     fib(n, m);
<     write m;
<     write "\n";
< end
< 
< proc fib(val int n, ref int out)
<     int fA;
<     int fB;
< 
<     if n <= 1 then
<         out := n;
<     else
<         fib(n - 2, fA);
<         fib(n - 1, fB);
<         out := fA + fB;
<     fi
< end
---
> fname => ../data/fib.bean

******************************************   Parsing gcd.bean:

Syntax error
Mismatch:
1,33c1
< 
< proc main()
<     int x;
<     int y;
<     int temp;
<     int quotient;
<     int remainder;
< 
<     write "Input two positive integers: ";
<     read x;
<     read y;
<     write "\n";
<     if x < y then
<         temp := x;
<         x := y;
<         y := temp;
<     fi
<     write "The gcd of ";
<     write x;
<     write " and ";
<     write y;
<     write " is ";
<     quotient := x / y;
<     remainder := x - quotient * y;
<     while remainder > 0 do
<         x := y;
<         y := remainder;
<         quotient := x / y;
<         remainder := x - quotient * y;
<     od
<     write y;
<     write "\n";
< end
---
> fname => ../data/gcd.bean

******************************************   Parsing hail.bean:

Syntax error
Mismatch:
1,30c1
< 
< proc main()
<     int n;
<     int result;
< 
<     n := 1;
<     while n < 21 do
<         hail(n, result);
<         write result;
<         write " ";
<         n := n + 1;
<     od
<     write "\n";
< end
< 
< proc hail(val int in, ref int out)
<     int count;
< 
<     count := 1;
<     if in = 1 then
<         out := count;
<     else
<         if in / 2 * 2 = in then
<             hail(in / 2, count);
<         else
<             hail(3 * in + 1, count);
<         fi
<         out := count + 1;
<     fi
< end
---
> fname => ../data/hail.bean

******************************************   Parsing power.bean:

Syntax error
Mismatch:
1,30c1
< 
< proc main()
<     float x;
<     float result;
<     int n;
< 
<     write "Float x: ";
<     read x;
<     write "Positive integer n: ";
<     read n;
<     power(x, n, result);
<     write "x^n is: ";
<     write result;
<     write "\n";
< end
< 
< proc power(val float x, val int n, ref float out)
<     float res;
< 
<     if n = 1 then
<         out := x;
<     else
<         power(x * x, n / 2, res);
<         if 2 * (n / 2) = n then
<             out := res;
<         else
<             out := x * res;
<         fi
<     fi
< end
---
> fname => ../data/power.bean

******************************************   Parsing stddev.bean:

Syntax error
Mismatch:
1,27c1
< 
< proc main()
<     int x;
<     int sum;
<     int sumsq;
<     int mean;
<     int count;
<     int done;
< 
<     write "Type a list of integers, ending with a negative number\n";
<     read x;
<     done := x < 0;
<     while not done do
<         count := count + 1;
<         sum := sum + x;
<         sumsq := sumsq + x * x;
<         read x;
<         done := x < 0;
<     od
<     mean := sum / count;
<     write "The mean is ";
<     write mean;
<     write "\n";
<     write "The variance is ";
<     write sumsq / count - mean * mean;
<     write "\n";
< end
---
> fname => ../data/stddev.bean

******************************************   Parsing strange.bean:

Syntax error
Mismatch:
1,38c1
< typedef {fA : int, fB : {gA : bool, fB : bool}} a_record
< typedef {used : bool, rec : a_record} b_record
< 
< proc q(val bool x, ref b_record k)
<     int n;
<     bool y;
<     a_record z;
< 
<     z.fA := 42;
<     z.fB := {fB = true, gA = false};
< end
< 
< proc p(ref int i)
< 
<     i := 6 * i + 4;
< end
< 
< proc main()
<     int m;
<     int n;
< 
<     read n;
<     while n > 1 do
<         m := n;
<         while m > 0 do
<             if m > 0 then
<                 n := n - 1;
<                 m := m - 1;
<                 if m = 0 then
<                     p(n);
<                 fi
<             else
<                 m := n - m;
<                 m := m - 1;
<             fi
<         od
<     od
< end
---
> fname => ../data/strange.bean

******************************************   Parsing lex11.bad.bean:
proc main()
int x;
  x := @ ;
end
Result:
fname => ../data/lex11.bad.bean 
Syntax error

******************************************   Parsing lex12.bad.bean:
proc main()
int x;
int xyz_ab$;
bool z;
    x := 3;
    z := true;
    write z;
end
Result:
fname => ../data/lex12.bad.bean 
Syntax error

******************************************   Parsing lex13.bad.bean:
proc main()
    int int; int := 0;
end
Result:
fname => ../data/lex13.bad.bean 
Syntax error

******************************************   Parsing syn12.bad.bean:
proc main ()
    bool test; 
end

proc fib(int val n, ref int ref out)
    int f1;
    int f2;

    out := n;
}

Result:
fname => ../data/syn12.bad.bean 
Syntax error

******************************************   Parsing syn13.bad.bean:
proc main()
int x;
int y;
# Sequence of statements cannot be empty
end

Result:
fname => ../data/syn13.bad.bean 
Syntax error

******************************************   Parsing syn14.bad.bean:
proc main()
int m;
int n;
    read n;
    while n>1 do
        m := ( n;
        while m := m do
            if then
                n := n - 1;
                m := m - 1
                if true then m := m - 1; else n := 6*n + 4;
                fi
             fi
        od
    od
end
Result:
fname => ../data/syn14.bad.bean 
Syntax error

******************************************   Parsing syn15.bad.bean:
proc main()
    int x; x := 0; x := 1
end
Result:
fname => ../data/syn15.bad.bean 
Syntax error

******************************************   Parsing syn16.bad.bean:
proc main()
typedef {b: int} t

t a;
    t.b := 0;
end
Result:
fname => ../data/syn16.bad.bean 
Syntax error

******************************************   Parsing syn17.bad.bean:
proc main()
int n;
    n := 0;
end
    n := 1;
Result:
fname => ../data/syn17.bad.bean 
Syntax error

******************************************   Parsing syn18.bad.bean:
proc main()
int m;
int n;
    read m;
    write if m=n then
end
Result:
fname => ../data/syn18.bad.bean 
Syntax error

******************************************   Parsing syn19.bad.bean:
proc main(val int a, ref)
int m; read m;
end
Result:
fname => ../data/syn19.bad.bean 
Syntax error


--- End of testing for bingfengl ---\n

============================================
src/bean_pprint.ml
02:18:31_Monday_11_April_2016
============================================
open Bean_ast
open Format

let print_program fmt prog = (
	Format.set_max_indent 100;
	printTypedefList fmt prog.typedefs;
	printFuncdefList fmt prog.funcdefs
)
============================================
src/bean_pprint.mli
02:18:31_Monday_11_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/bean_lex.mll
02:18:31_Monday_11_April_2016
============================================
{
open Bean_parse
let line_num = ref 0

exception LexFail of Lexing.lexbuf


let lex_fail lexbuf = raise (LexFail lexbuf)
}

let apostro = '''
let digit = ['0' - '9']
let alpha = ['a' - 'z' 'A' - 'Z']
let alnum = alpha | digit (* unused *)
let digits = digit+ (* unused *)
let underscore = '_'
let ident = (alpha|underscore)(alpha|underscore|apostro)* (* to be changed to (alpha|underscore)(alpha|underscore|apostro)* *)
let typedef_value_init = (ident ':' ident) (* unused *)
let function_value_init = ident ident (* unused *)

let comment = '#'[^'\n']*'\n'

rule token = parse
    [' ' '\t']    { token lexbuf }     (* skip blanks *)
  | '\n'          { incr line_num; Lexing.new_line lexbuf ; token lexbuf }
  (*| '-'?['0'-'9']+ as lxm { IPrintf.printf "meet typedef \n" ;flush stdout;NT_CONST(int_of_string lxm) }*)
  | '-'?['0'-'9']+ as lxm{INT_VAL(int_of_string(lxm)) }
  (* keywords *)
  | comment {incr line_num;token lexbuf }
  | ':' { flush stdout;COLON }
  | '{' { LEFT_BRACE }
  | '}' { RIGHT_BRACE }
  | "typedef" {TYPEDEF("typedef") }
  | "proc" {PROC}
  (*| typedef_value_init  as temp{ Printf.printf "meet typedef_value_init => %s \n" temp;flush stdout;TYPEDEF_VALUE_INIT }*)
  | ',' { COMMA }
  | '.' { DOT }
  | "end" { END }
  | "val" { VAL }
  | "ref" {REF }
  | '(' { LEFT_PAREN }
  | ')' { RIGHT_PAREN }
  | "while" {WHILE }
  | "do" { DO }
  | "od" { OD }
  | "if" { IF }
  | "then" {THEN }
  | "else" {ELSE }
  | "fi" {FI} 
  | "bool" {BOOL }
  | "int" { INT }
  (*| "true" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL true }*)
  | "true" {BOOL_VAL true}
  (*| "false" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL false }*)
  | "false" {BOOL_VAL false}
  | "read" { READ }
  | "write" { WRITE }
  (*| ":=" { Printf.printf "meet typedef \n" ;flush stdout;ASSIGN }*)
  | ":=" {EQ_COL}
  (*| '(' { LPAREN }*)
  (*| ')' { RPAREN }*)
  | "!=" {NEQ }
  | "<="{ LTE }
  | ">="{ GTE }
  | '=' { EQ }
  | '<' { LT }
  | '+' { PLUS }
  | '-' { MINUS }
  | '*' { MUL }
  | ';' { SEMICOLON }
  | '>' { GT}
  | '"' [^ '"' '\t' '\n' '\r' ]* '"' as lxm{STRING_VAL(lxm)}
  (*| ident as lxm { IDENT lxm }*)
  | ident as lxm{IDENTIFIER(lxm) }
  | eof { EOF }
  | _   { lex_fail lexbuf }
============================================
src/Makefile
02:18:31_Monday_11_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o ./bean *.byte
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/Makefile.depend
02:18:31_Monday_11_April_2016
============================================
bean.cmo :
bean.cmx :
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi :
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_pprint.cmi
bean_pprint.cmx : bean_pprint.cmi
bean.cmo :
bean.cmx :
============================================
src/bean_ast.ml
02:18:31_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty


type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)




type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref


type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program

(*
let printBeantype beanTypeData = match beanTypeData with
| Bool -> Printf.printf " Bool "
| Int -> Printf.printf " Int "
| IdentType(s) ->  Printf.printf " string => %s" s

let rec printTypedefStruct typedefStructData = match typedefStructData with
| SingleTypeTerm(id , tp) -> (Printf.printf "id => %s , type => \n" id ; printBeantype tp)
| ListTypeTerm(id , tps) -> (Printf.printf "Listype name => %s " id;List.iter (printTypedefStruct) tps)

let rec printTypedefs typedefData = match typedefData with
| [] -> Printf.printf "Empty \n "
| (hstructList,hid)::t -> ( Printf.printf "typedef name => %s : \n  " hid; List.iter (printTypedefStruct) hstructList ; printTypedefs t )

*)

(* Print typedef *)

let printBeanType fmt (btype,suffix) =  match btype with
| Bool -> Format.fprintf fmt "bool%s" suffix 
| Int ->  Format.fprintf fmt "int%s" suffix  
| IdentType(ident) -> Format.fprintf fmt "%s%s" ident suffix

(* mode = 1 ==> in typedef *)
let rec printTypedefStruct fmt (arrangeMode,typedefStructData) = match typedefStructData with
| SingleTypeTerm (btype) -> if arrangeMode = 1 then printBeanType fmt (btype,"") else printBeanType fmt (btype," ")
| SingleTypeTermWithIdent (ident,nestTypedefStructData) ->
  if arrangeMode = 1 then Format.fprintf fmt "%s : %a" ident printTypedefStruct (arrangeMode,nestTypedefStructData)
  else Format.fprintf fmt "%a%s" printTypedefStruct (arrangeMode,nestTypedefStructData) ident
| ListTypeTerm (listTypedefStructData) ->(Format.fprintf fmt "{"  ;
  List.iter (fun x -> if x = List.nth listTypedefStructData ((List.length listTypedefStructData)-1) 
    then printTypedefStruct fmt (arrangeMode,x)
    else (printTypedefStruct fmt (arrangeMode,x) ; Format.fprintf fmt ", ")) listTypedefStructData;
  Format.fprintf fmt "}" )
| TypedefEnd -> Format.fprintf fmt "end with type def \n"

let printSingleTypedef fmt singleTypedefData = let arrangeMode = 1 in match singleTypedefData with
| (typedefStruct,ident) -> Format.fprintf fmt "typedef %a %s\n" printTypedefStruct (arrangeMode,typedefStruct) ident 
 

let printTypedefList fmt typedefDataList = (Format.fprintf fmt "@[";
  List.iter (printSingleTypedef fmt) typedefDataList;
  Format.fprintf fmt "@]@.")




(* Print method delc*)


let printFuncIndicator fmt funcIndicator = match funcIndicator with
| Val -> Format.fprintf fmt "val "
| Ref -> Format.fprintf fmt "ref "

let printFuncparams fmt singleFuncparamData =  let arrangeMode = 1 in match singleFuncparamData with
| (funcIndicator,typedefStruct,ident) -> Format.fprintf fmt  "%a%a %s"  printFuncIndicator funcIndicator printTypedefStruct (arrangeMode,typedefStruct) ident

let printFuncheader fmt funcheaderData = match funcheaderData with
| (funcname,funcparams) -> (Format.fprintf fmt "%s(" funcname ;
List.iter (fun x -> if x = List.nth funcparams ((List.length funcparams)-1) 
    then printFuncparams fmt x
    else (printFuncparams fmt x ; Format.fprintf fmt ", ")) funcparams;
    Format.fprintf fmt ")")


let printFuncVardef fmt funcVardefData = let arrangeMode = 2 in List.iter (fun x -> 
   if x = List.nth funcVardefData ((List.length funcVardefData)-1)
   then (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";")
   else (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";@ "))
  funcVardefData


(*//TODO *)
let rec printLvalue fmt singleLvalue = match singleLvalue with
| LId(ident) -> Format.fprintf fmt "%s" ident
| LField(recLvalue,ident) -> (Format.fprintf fmt "%s." ident; printLvalue fmt recLvalue)
| LvalueNone -> Format.fprintf fmt "Empty lvalue"

let printBinop fmt singleBinop = match singleBinop with
| Op_add -> Format.fprintf fmt  " + "
| Op_sub -> Format.fprintf fmt  " - "
| Op_mul -> Format.fprintf fmt  " * "
| Op_div -> Format.fprintf fmt " / " 
| Op_eq -> Format.fprintf fmt  " = "
| Op_lt -> Format.fprintf fmt  " < "
| Op_gt -> Format.fprintf fmt  " > "
| Op_neq -> Format.fprintf fmt  " != "
| Op_lte -> Format.fprintf fmt  " <= "
| Op_gte -> Format.fprintf fmt  " >= "
| Op_and -> Format.fprintf fmt  " and "
| Op_or -> Format.fprintf fmt  " or "

let printUnop fmt singleUnop = match singleUnop with
| Op_minus -> Format.fprintf fmt "-"
| Op_not -> Format.fprintf fmt "!"

let rec printExpr fmt singleExpr = match singleExpr with
| Ebool(bool_val) -> Format.fprintf fmt "%B" bool_val
| Eint(int_val) -> Format.fprintf fmt "%d" int_val
| Elval(lvalue) -> printLvalue fmt lvalue
| Ebinop(expr_one,binop,expr_two) -> (printExpr fmt expr_one;
  printBinop fmt binop; printExpr fmt expr_two)
| Eunop(unop,expr) -> (printUnop fmt unop ; printExpr fmt expr)
| Eident(ident) -> Format.fprintf fmt "%s " ident
| Ebracket(expr) -> (Format.fprintf fmt "( " ; printExpr fmt expr  ;Format.fprintf fmt " ) ")


let rec printRvalue fmt singleRvalue = match singleRvalue with
| Rexpr(expr) -> printExpr fmt expr
| RField(rvalue,expr) -> (printRvalue fmt rvalue;
  printExpr fmt expr)
| Rassign(str,rvalue) -> (Format.fprintf fmt "%s = " str;
  printRvalue fmt rvalue)
| Rstmts(rvalueList) -> (Format.fprintf fmt "{";
  List.iter (fun x ->( if x = List.nth rvalueList ((List.length rvalueList)-1) 
  then printRvalue fmt x
  else (printRvalue fmt x ;Format.fprintf fmt ", ") )) rvalueList;
  Format.fprintf fmt "}")
| Rempty -> Format.fprintf fmt "Empty Rvalue "

let getIdent identNum = String.make identNum ' '

let printEndStmt fmt isLast lastStr = match isLast with
  | true -> Format.fprintf fmt  "%s" lastStr
  | false -> Format.fprintf fmt  "%s@ " lastStr

let rec printStmt fmt (initIdent,isLast,singleStmt) = match singleStmt with

| Assign(lvalue, rvalue) -> (printLvalue fmt lvalue;
  Format.fprintf fmt  " := ";
  printRvalue fmt rvalue;
  printEndStmt fmt isLast ";")

| AssignRvalueList(lvalue,rvalueList) ->(printLvalue fmt lvalue;
  Format.fprintf fmt  "={";
  List.iter (printRvalue fmt) rvalueList;
  Format.fprintf fmt "}";
  printEndStmt fmt isLast ";")

| Read(lvalue) -> (Format.fprintf fmt  "read ";
  printLvalue fmt lvalue;
  printEndStmt fmt isLast ";")

| Write(expr) -> (Format.fprintf fmt  "write ";
  printExpr fmt expr;
  printEndStmt fmt isLast ";")

| StmtNone -> Format.fprintf fmt "StmtNone"

| Method(methodname, paramList) -> (Format.fprintf fmt "%s(" methodname ;
  List.iter (fun x -> if x = List.nth paramList ((List.length paramList)-1) 
  then printExpr fmt x
  else (printExpr fmt x; Format.fprintf fmt ", " )) paramList;
  Format.fprintf fmt ")";
  printEndStmt fmt isLast ";")

| VarDec(beantype, ident) -> (printBeanType fmt (beantype,"");
  Format.fprintf fmt "%s " ident;
  printEndStmt fmt isLast ";")

| WhileDec(expr, stmtList) ->(Format.fprintf fmt "while %a do @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth stmtList ((List.length stmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) stmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt"@ od";
  printEndStmt fmt isLast "")

| IfDec(expr, thenStmtList, elseStmtList) -> (Format.fprintf fmt "if %a then @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth thenStmtList ((List.length thenStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) thenStmtList;
  Format.fprintf fmt " @]";
  if (List.length elseStmtList) != 0 then (Format.fprintf fmt " @ ";Format.fprintf fmt "else @ ");
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth elseStmtList ((List.length elseStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) elseStmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt  "@ fi";
  printEndStmt fmt isLast "")

let printFuncBody fmt funcBodyData = let initIdentFactor = 4 in List.iter (fun x -> if x = List.nth funcBodyData ((List.length funcBodyData)-1) 
    then printStmt fmt (initIdentFactor,true,x)
    else printStmt fmt (initIdentFactor,false,x)) funcBodyData
(*
let printSingleFuncdef fmt initIdent initIdentFactor singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) -> Format.fprintf fmt "@[proc %a @ %a @ @ %a end@]@." printFuncheader (initIdent,initIdentFactor,funcheader) printFuncVardef (initIdent,initIdentFactor,funcvardef)  printFuncBody (initIdent,initIdentFactor,funcbody)
*)
let printSingleFuncdef fmt singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) ->(Format.fprintf fmt "proc %a" printFuncheader funcheader;
  if (List.length funcvardef) !=0 then Format.fprintf fmt " @ %a " printFuncVardef funcvardef;
  if (List.length funcbody) != 0 then Format.fprintf fmt " @ @ %a " printFuncBody funcbody;
  Format.fprintf fmt "\nend\n\n")

let printFuncdefList fmt funcdefDataList = let iniIdent = 4 in (Format.fprintf fmt "@[<v %d>" iniIdent ; List.iter (printSingleFuncdef fmt) funcdefDataList ;Format.fprintf fmt "@] " )









============================================
src/bean_ast.mli
02:18:31_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty

type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)


type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref



type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program
(*
val printBeantype : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit 
val printTypedefs : (typedefStruct list * ident) list -> unit
*)
(*
val printBeanType : beantype -> unit 
val printSingleTypeDef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit 
*)
(*
val printBeanType : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit
val printSingleTypedef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit
*)
(*
val printFuncIndicator : valRef -> unit
val printFuncparams : valRef * typedefStruct * ident -> unit
val printFuncheader : ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : typedefStruct list -> unit
val printLvalue : lvalue -> unit
val printBinop : binop -> unit
val printUnop : unop -> unit
val printExpr : expr -> unit
val printRvalue : rvalue -> unit
val printStmt : stmt -> unit
val printFuncBody : stmt list -> unit
val printSingleFuncdef : (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit 
val printFuncdefList : ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit*)
val printBeanType : Format.formatter -> beantype * string -> unit
val printTypedefStruct : Format.formatter -> int * typedefStruct -> unit
val printSingleTypedef : Format.formatter -> typedefStruct * ident -> unit
val printTypedefList : Format.formatter -> (typedefStruct * ident) list -> unit
val printFuncIndicator : Format.formatter -> valRef -> unit
val printFuncparams : Format.formatter -> valRef * typedefStruct * ident -> unit
val printFuncheader : Format.formatter -> ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : Format.formatter -> typedefStruct list -> unit
val printLvalue : Format.formatter -> lvalue -> unit
val printBinop : Format.formatter -> binop -> unit
val printUnop : Format.formatter -> unop -> unit
val printExpr : Format.formatter -> expr -> unit
val printRvalue : Format.formatter -> rvalue -> unit
val getIdent : int -> ident
val printEndStmt : Format.formatter -> bool -> ident -> unit
val printStmt : Format.formatter -> int * bool * stmt -> unit
val printFuncBody : Format.formatter -> stmt list -> unit
val printSingleFuncdef : Format.formatter -> (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit
val printFuncdefList : Format.formatter -> ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit============================================
src/bean_parse.mly
02:18:31_Monday_11_April_2016
============================================
/* ocamlyacc parser for bean */
%{
open Bean_ast
%}

%token <bool> BOOL_VAL
%token <int> INT_VAL
%token <string> STRING_VAL
%token WRITE READ
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token PLUS MINUS MUL DIV
%token UMINUS
%token COLON
%token SEMICOLON
%token AND OR NOT
%token EOF


%token <string> IDENTIFIER
%token LEFT_PAREN RIGHT_PAREN
%token <string> TYPEDEF
%token TYPEDEF_VALUE_INIT
%token DOT
%token COMMA
%token END
%token VAL
%token REF
%token LEFT_BRACE RIGHT_BRACE
%token WHILE DO OD
%token IF THEN ELSE FI
%token BOOL INT
%token PROC
%token EQ_COL
%left OR
%left AND
%nonassoc EQ NEQ LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right EQ_COL
%nonassoc NOT UMINUS

%type <Bean_ast.program> start_state

%start start_state
%%


/*
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
*/

start_state:
| type_definition procedure_definition {{typedefs = List.rev $1;funcdefs = List.rev $2}}

/*typdef ? identifier*/
type_definition:
/*| type_definition TYPEDEF type_spec IDENTIFIER {($3,$4)::$1}*/
| {[]}
| type_definition IDENTIFIER type_spec IDENTIFIER {($3,$4)::$1}

type_spec:
| primitive_type {$1}
| IDENTIFIER {SingleTypeTerm((IdentType $1))}
/*typdef {?} identifier*/
| LEFT_BRACE field_definition RIGHT_BRACE {ListTypeTerm( List.rev $2)}

primitive_type:
| BOOL {SingleTypeTerm(Bool)}
| INT {SingleTypeTerm(Int)}

field_definition:
| rec_field_definition IDENTIFIER COLON type_spec {SingleTypeTermWithIdent($2,$4)::$1}

rec_field_definition:
| field_definition COMMA {$1}
| {[]}








/* At least one procedure required */
/* (functionDeclaration * typedefStruct  * stmt list) list */
procedure_definition:
/*| rec_procedure_definition PROC procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}*/
| rec_procedure_definition IDENTIFIER  procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}
/* (functionDeclaration * typedefStruct  * stmt list) list */
rec_procedure_definition:
| procedure_definition {$1}
| {[]}

/*type functionDeclaration = (string*funcDecParamList)*/
/*type funcDecParamList = (valRef*typedefStruct*string) list*/
procedure_header:
| IDENTIFIER LEFT_PAREN param RIGHT_PAREN {($1,List.rev $3)}


/*type funcDecParamList = (valRef*typedefStruct*string) list*/
param:
| rec_param param_passing_indicator type_spec IDENTIFIER {($2,$3,$4)::$1}
| {[]}

/*type funcDecParamList = (valRef*typedefStruct*string)*/

rec_param:
| param COMMA {$1}
| {[]}

/* type valRef  */
param_passing_indicator:
| VAL {Val}
| REF {Ref}


/*typedefStruct*/
variable_definition:
| variable_definition type_spec IDENTIFIER SEMICOLON { SingleTypeTermWithIdent($3,$2)::$1 }
| {[]}

/*procedure , stmt list*/

/* stmt list */
procedure_body:
| atomic_stmt SEMICOLON rec_procedure_body {$1::$3}
| compound_stmt rec_procedure_body {$1::$2}

rec_procedure_body:
| procedure_body {$1}
| {[]}

/* stmt */
atomic_stmt:
| lvalue EQ_COL rvalue { Assign($1,$3)}
| READ lvalue { Read($2) }
| WRITE expr { Write($2) }
| IDENTIFIER LEFT_PAREN expr_list RIGHT_PAREN { Method($1,$3) }

/* stmt */
compound_stmt:
| IF expr THEN stmt_list else_block FI {IfDec($2,$4,$5)}
| WHILE expr DO stmt_list OD {WhileDec($2,$4)}


/* object.field*/
lvalue:
| IDENTIFIER { LId($1) }
| lvalue DOT IDENTIFIER { LField($1,$3) }

/* rvalue*/
rvalue:
| expr { Rexpr($1) }
| LEFT_BRACE field_init RIGHT_BRACE { Rstmts(List.rev $2) }
| LEFT_BRACE RIGHT_BRACE { Rempty }

/* rvalue list */
field_init:
| rec_field_init IDENTIFIER EQ rvalue {Rassign($2,$4)::$1}

rec_field_init:
| field_init COMMA {$1}
| {[]}

expr:
| lvalue { Elval($1) }
| const { $1 }
| LEFT_PAREN expr RIGHT_PAREN { Ebracket($2) }
| expr PLUS expr { Ebinop($1,Op_add,$3) }
| expr MINUS expr { Ebinop($1,Op_sub,$3) }
| expr MUL expr { Ebinop($1,Op_mul,$3) }
| expr DIV expr { Ebinop($1,Op_div,$3) }
| expr EQ expr { Ebinop($1,Op_eq,$3) }
| expr NEQ expr { Ebinop($1,Op_neq,$3) }
| expr LT expr { Ebinop($1,Op_lt,$3) }
| expr GT expr { Ebinop($1,Op_gt,$3) }
| expr LTE expr { Ebinop($1,Op_lte,$3) }
| expr GTE expr { Ebinop($1,Op_gte,$3) }
| expr AND expr { Ebinop($1,Op_and,$3) }
| expr OR expr { Ebinop($1,Op_or,$3) }
| NOT expr { Eunop(Op_not,$2) }
| UMINUS expr { Eunop(Op_minus,$2) }

/* expr list */
expr_list:
| expr rec_expr_list { $1::$2 }
| {[]}

rec_expr_list:
| COMMA expr_list { $2 }
| {[]}

stmt_list:
| procedure_body {$1}

else_block:
| ELSE stmt_list {$2}
| {[]}

const:
| BOOL_VAL { Ebool($1) }
| INT_VAL { Eint($1) }
| STRING_VAL { Eident($1) }
============================================
src/feedback.txt
02:18:31_Monday_11_April_2016
============================================
============================================
vis/bingfengl.out
02:16:28_Monday_11_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  bingfengl

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc bean_parse.mly
File "bean_parse.mly", line 63: $4 is unbound
make: *** [bean_parse.mli] Error 1

make failed (exited with status 2)

--- End of testing for bingfengl ---\n

============================================
src/bean_pprint.ml
02:16:27_Monday_11_April_2016
============================================
open Bean_ast
open Format

let print_program fmt prog = (
	Format.set_max_indent 100;
	printTypedefList fmt prog.typedefs;
	printFuncdefList fmt prog.funcdefs
)
============================================
src/bean_lex.mll
02:16:27_Monday_11_April_2016
============================================
{
open Bean_parse
let line_num = ref 0

exception LexFail of Lexing.lexbuf


let lex_fail lexbuf = raise (LexFail lexbuf)
}

let apostro = '''
let digit = ['0' - '9']
let alpha = ['a' - 'z' 'A' - 'Z']
let alnum = alpha | digit (* unused *)
let digits = digit+ (* unused *)
let underscore = '_'
let ident = (alpha|underscore)(alpha|underscore|apostro)* (* to be changed to (alpha|underscore)(alpha|underscore|apostro)* *)
let typedef_value_init = (ident ':' ident) (* unused *)
let function_value_init = ident ident (* unused *)

let comment = '#'[^'\n']*'\n'

rule token = parse
    [' ' '\t']    { token lexbuf }     (* skip blanks *)
  | '\n'          { incr line_num; Lexing.new_line lexbuf ; token lexbuf }
  (*| '-'?['0'-'9']+ as lxm { IPrintf.printf "meet typedef \n" ;flush stdout;NT_CONST(int_of_string lxm) }*)
  | '-'?['0'-'9']+ as lxm{INT_VAL(int_of_string(lxm)) }
  (* keywords *)
  | comment {incr line_num;token lexbuf }
  | ':' { flush stdout;COLON }
  | '{' { LEFT_BRACE }
  | '}' { RIGHT_BRACE }
  | "typedef" {TYPEDEF("typedef") }
  | "proc" {PROC}
  (*| typedef_value_init  as temp{ Printf.printf "meet typedef_value_init => %s \n" temp;flush stdout;TYPEDEF_VALUE_INIT }*)
  | ',' { COMMA }
  | '.' { DOT }
  | "end" { END }
  | "val" { VAL }
  | "ref" {REF }
  | '(' { LEFT_PAREN }
  | ')' { RIGHT_PAREN }
  | "while" {WHILE }
  | "do" { DO }
  | "od" { OD }
  | "if" { IF }
  | "then" {THEN }
  | "else" {ELSE }
  | "fi" {FI} 
  | "bool" {BOOL }
  | "int" { INT }
  (*| "true" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL true }*)
  | "true" {BOOL_VAL true}
  (*| "false" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL false }*)
  | "false" {BOOL_VAL false}
  | "read" { READ }
  | "write" { WRITE }
  (*| ":=" { Printf.printf "meet typedef \n" ;flush stdout;ASSIGN }*)
  | ":=" {EQ_COL}
  (*| '(' { LPAREN }*)
  (*| ')' { RPAREN }*)
  | "!=" {NEQ }
  | "<="{ LTE }
  | ">="{ GTE }
  | '=' { EQ }
  | '<' { LT }
  | '+' { PLUS }
  | '-' { MINUS }
  | '*' { MUL }
  | ';' { SEMICOLON }
  | '>' { GT}
  | '"' [^ '"' '\t' '\n' '\r' ]* '"' as lxm{STRING_VAL(lxm)}
  (*| ident as lxm { IDENT lxm }*)
  | ident as lxm{IDENTIFIER(lxm) }
  | eof { EOF }
  | _   { lex_fail lexbuf }
============================================
src/bean_ast.ml
02:16:27_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty


type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)




type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref


type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program

(*
let printBeantype beanTypeData = match beanTypeData with
| Bool -> Printf.printf " Bool "
| Int -> Printf.printf " Int "
| IdentType(s) ->  Printf.printf " string => %s" s

let rec printTypedefStruct typedefStructData = match typedefStructData with
| SingleTypeTerm(id , tp) -> (Printf.printf "id => %s , type => \n" id ; printBeantype tp)
| ListTypeTerm(id , tps) -> (Printf.printf "Listype name => %s " id;List.iter (printTypedefStruct) tps)

let rec printTypedefs typedefData = match typedefData with
| [] -> Printf.printf "Empty \n "
| (hstructList,hid)::t -> ( Printf.printf "typedef name => %s : \n  " hid; List.iter (printTypedefStruct) hstructList ; printTypedefs t )

*)

(* Print typedef *)

let printBeanType fmt (btype,suffix) =  match btype with
| Bool -> Format.fprintf fmt "bool%s" suffix 
| Int ->  Format.fprintf fmt "int%s" suffix  
| IdentType(ident) -> Format.fprintf fmt "%s%s" ident suffix

(* mode = 1 ==> in typedef *)
let rec printTypedefStruct fmt (arrangeMode,typedefStructData) = match typedefStructData with
| SingleTypeTerm (btype) -> if arrangeMode = 1 then printBeanType fmt (btype,"") else printBeanType fmt (btype," ")
| SingleTypeTermWithIdent (ident,nestTypedefStructData) ->
  if arrangeMode = 1 then Format.fprintf fmt "%s : %a" ident printTypedefStruct (arrangeMode,nestTypedefStructData)
  else Format.fprintf fmt "%a%s" printTypedefStruct (arrangeMode,nestTypedefStructData) ident
| ListTypeTerm (listTypedefStructData) ->(Format.fprintf fmt "{"  ;
  List.iter (fun x -> if x = List.nth listTypedefStructData ((List.length listTypedefStructData)-1) 
    then printTypedefStruct fmt (arrangeMode,x)
    else (printTypedefStruct fmt (arrangeMode,x) ; Format.fprintf fmt ", ")) listTypedefStructData;
  Format.fprintf fmt "}" )
| TypedefEnd -> Format.fprintf fmt "end with type def \n"

let printSingleTypedef fmt singleTypedefData = let arrangeMode = 1 in match singleTypedefData with
| (typedefStruct,ident) -> Format.fprintf fmt "typedef %a %s\n" printTypedefStruct (arrangeMode,typedefStruct) ident 
 

let printTypedefList fmt typedefDataList = (Format.fprintf fmt "@[";
  List.iter (printSingleTypedef fmt) typedefDataList;
  Format.fprintf fmt "@]@.")




(* Print method delc*)


let printFuncIndicator fmt funcIndicator = match funcIndicator with
| Val -> Format.fprintf fmt "val "
| Ref -> Format.fprintf fmt "ref "

let printFuncparams fmt singleFuncparamData =  let arrangeMode = 1 in match singleFuncparamData with
| (funcIndicator,typedefStruct,ident) -> Format.fprintf fmt  "%a%a %s"  printFuncIndicator funcIndicator printTypedefStruct (arrangeMode,typedefStruct) ident

let printFuncheader fmt funcheaderData = match funcheaderData with
| (funcname,funcparams) -> (Format.fprintf fmt "%s(" funcname ;
List.iter (fun x -> if x = List.nth funcparams ((List.length funcparams)-1) 
    then printFuncparams fmt x
    else (printFuncparams fmt x ; Format.fprintf fmt ", ")) funcparams;
    Format.fprintf fmt ")")


let printFuncVardef fmt funcVardefData = let arrangeMode = 2 in List.iter (fun x -> 
   if x = List.nth funcVardefData ((List.length funcVardefData)-1)
   then (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";")
   else (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";@ "))
  funcVardefData


(*//TODO *)
let rec printLvalue fmt singleLvalue = match singleLvalue with
| LId(ident) -> Format.fprintf fmt "%s" ident
| LField(recLvalue,ident) -> (Format.fprintf fmt "%s." ident; printLvalue fmt recLvalue)
| LvalueNone -> Format.fprintf fmt "Empty lvalue"

let printBinop fmt singleBinop = match singleBinop with
| Op_add -> Format.fprintf fmt  " + "
| Op_sub -> Format.fprintf fmt  " - "
| Op_mul -> Format.fprintf fmt  " * "
| Op_div -> Format.fprintf fmt " / " 
| Op_eq -> Format.fprintf fmt  " = "
| Op_lt -> Format.fprintf fmt  " < "
| Op_gt -> Format.fprintf fmt  " > "
| Op_neq -> Format.fprintf fmt  " != "
| Op_lte -> Format.fprintf fmt  " <= "
| Op_gte -> Format.fprintf fmt  " >= "
| Op_and -> Format.fprintf fmt  " and "
| Op_or -> Format.fprintf fmt  " or "

let printUnop fmt singleUnop = match singleUnop with
| Op_minus -> Format.fprintf fmt "-"
| Op_not -> Format.fprintf fmt "!"

let rec printExpr fmt singleExpr = match singleExpr with
| Ebool(bool_val) -> Format.fprintf fmt "%B" bool_val
| Eint(int_val) -> Format.fprintf fmt "%d" int_val
| Elval(lvalue) -> printLvalue fmt lvalue
| Ebinop(expr_one,binop,expr_two) -> (printExpr fmt expr_one;
  printBinop fmt binop; printExpr fmt expr_two)
| Eunop(unop,expr) -> (printUnop fmt unop ; printExpr fmt expr)
| Eident(ident) -> Format.fprintf fmt "%s " ident
| Ebracket(expr) -> (Format.fprintf fmt "( " ; printExpr fmt expr  ;Format.fprintf fmt " ) ")


let rec printRvalue fmt singleRvalue = match singleRvalue with
| Rexpr(expr) -> printExpr fmt expr
| RField(rvalue,expr) -> (printRvalue fmt rvalue;
  printExpr fmt expr)
| Rassign(str,rvalue) -> (Format.fprintf fmt "%s = " str;
  printRvalue fmt rvalue)
| Rstmts(rvalueList) -> (Format.fprintf fmt "{";
  List.iter (fun x ->( if x = List.nth rvalueList ((List.length rvalueList)-1) 
  then printRvalue fmt x
  else (printRvalue fmt x ;Format.fprintf fmt ", ") )) rvalueList;
  Format.fprintf fmt "}")
| Rempty -> Format.fprintf fmt "Empty Rvalue "

let getIdent identNum = String.make identNum ' '

let printEndStmt fmt isLast lastStr = match isLast with
  | true -> Format.fprintf fmt  "%s" lastStr
  | false -> Format.fprintf fmt  "%s@ " lastStr

let rec printStmt fmt (initIdent,isLast,singleStmt) = match singleStmt with

| Assign(lvalue, rvalue) -> (printLvalue fmt lvalue;
  Format.fprintf fmt  " := ";
  printRvalue fmt rvalue;
  printEndStmt fmt isLast ";")

| AssignRvalueList(lvalue,rvalueList) ->(printLvalue fmt lvalue;
  Format.fprintf fmt  "={";
  List.iter (printRvalue fmt) rvalueList;
  Format.fprintf fmt "}";
  printEndStmt fmt isLast ";")

| Read(lvalue) -> (Format.fprintf fmt  "read ";
  printLvalue fmt lvalue;
  printEndStmt fmt isLast ";")

| Write(expr) -> (Format.fprintf fmt  "write ";
  printExpr fmt expr;
  printEndStmt fmt isLast ";")

| StmtNone -> Format.fprintf fmt "StmtNone"

| Method(methodname, paramList) -> (Format.fprintf fmt "%s(" methodname ;
  List.iter (fun x -> if x = List.nth paramList ((List.length paramList)-1) 
  then printExpr fmt x
  else (printExpr fmt x; Format.fprintf fmt ", " )) paramList;
  Format.fprintf fmt ")";
  printEndStmt fmt isLast ";")

| VarDec(beantype, ident) -> (printBeanType fmt (beantype,"");
  Format.fprintf fmt "%s " ident;
  printEndStmt fmt isLast ";")

| WhileDec(expr, stmtList) ->(Format.fprintf fmt "while %a do @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth stmtList ((List.length stmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) stmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt"@ od";
  printEndStmt fmt isLast "")

| IfDec(expr, thenStmtList, elseStmtList) -> (Format.fprintf fmt "if %a then @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth thenStmtList ((List.length thenStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) thenStmtList;
  Format.fprintf fmt " @]";
  if (List.length elseStmtList) != 0 then (Format.fprintf fmt " @ ";Format.fprintf fmt "else @ ");
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth elseStmtList ((List.length elseStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) elseStmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt  "@ fi";
  printEndStmt fmt isLast "")

let printFuncBody fmt funcBodyData = let initIdentFactor = 4 in List.iter (fun x -> if x = List.nth funcBodyData ((List.length funcBodyData)-1) 
    then printStmt fmt (initIdentFactor,true,x)
    else printStmt fmt (initIdentFactor,false,x)) funcBodyData
(*
let printSingleFuncdef fmt initIdent initIdentFactor singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) -> Format.fprintf fmt "@[proc %a @ %a @ @ %a end@]@." printFuncheader (initIdent,initIdentFactor,funcheader) printFuncVardef (initIdent,initIdentFactor,funcvardef)  printFuncBody (initIdent,initIdentFactor,funcbody)
*)
let printSingleFuncdef fmt singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) ->(Format.fprintf fmt "proc %a" printFuncheader funcheader;
  if (List.length funcvardef) !=0 then Format.fprintf fmt " @ %a " printFuncVardef funcvardef;
  if (List.length funcbody) != 0 then Format.fprintf fmt " @ @ %a " printFuncBody funcbody;
  Format.fprintf fmt "\nend\n\n")

let printFuncdefList fmt funcdefDataList = let iniIdent = 4 in (Format.fprintf fmt "@[<v %d>" iniIdent ; List.iter (printSingleFuncdef fmt) funcdefDataList ;Format.fprintf fmt "@] " )









============================================
src/Makefile
02:16:27_Monday_11_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o ./bean *.byte
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/bean_pprint.mli
02:16:27_Monday_11_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/bean_parse.mly
02:16:27_Monday_11_April_2016
============================================
/* ocamlyacc parser for bean */
%{
open Bean_ast
%}

%token <bool> BOOL_VAL
%token <int> INT_VAL
%token <string> STRING_VAL
%token WRITE READ
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token PLUS MINUS MUL DIV
%token UMINUS
%token COLON
%token SEMICOLON
%token AND OR NOT
%token EOF


%token <string> IDENTIFIER
%token LEFT_PAREN RIGHT_PAREN
%token <string> TYPEDEF
%token TYPEDEF_VALUE_INIT
%token DOT
%token COMMA
%token END
%token VAL
%token REF
%token LEFT_BRACE RIGHT_BRACE
%token WHILE DO OD
%token IF THEN ELSE FI
%token BOOL INT
%token PROC
%token EQ_COL
%left OR
%left AND
%nonassoc EQ NEQ LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right EQ_COL
%nonassoc NOT UMINUS

%type <Bean_ast.program> start_state

%start start_state
%%


/*
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
*/

start_state:
| type_definition procedure_definition {{typedefs = List.rev $1;funcdefs = List.rev $2}}

/*typdef ? identifier*/
type_definition:
/*| type_definition TYPEDEF type_spec IDENTIFIER {($3,$4)::$1}*/
| {[]}
| type_definition type_spec IDENTIFIER {($3,$4)::$1}

type_spec:
| primitive_type {$1}
| IDENTIFIER {SingleTypeTerm((IdentType $1))}
/*typdef {?} identifier*/
| LEFT_BRACE field_definition RIGHT_BRACE {ListTypeTerm( List.rev $2)}

primitive_type:
| BOOL {SingleTypeTerm(Bool)}
| INT {SingleTypeTerm(Int)}

field_definition:
| rec_field_definition IDENTIFIER COLON type_spec {SingleTypeTermWithIdent($2,$4)::$1}

rec_field_definition:
| field_definition COMMA {$1}
| {[]}








/* At least one procedure required */
/* (functionDeclaration * typedefStruct  * stmt list) list */
procedure_definition:
/*| rec_procedure_definition PROC procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}*/
| rec_procedure_definition  procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}
/* (functionDeclaration * typedefStruct  * stmt list) list */
rec_procedure_definition:
| procedure_definition {$1}
| {[]}

/*type functionDeclaration = (string*funcDecParamList)*/
/*type funcDecParamList = (valRef*typedefStruct*string) list*/
procedure_header:
| IDENTIFIER LEFT_PAREN param RIGHT_PAREN {($1,List.rev $3)}


/*type funcDecParamList = (valRef*typedefStruct*string) list*/
param:
| rec_param param_passing_indicator type_spec IDENTIFIER {($2,$3,$4)::$1}
| {[]}

/*type funcDecParamList = (valRef*typedefStruct*string)*/

rec_param:
| param COMMA {$1}
| {[]}

/* type valRef  */
param_passing_indicator:
| VAL {Val}
| REF {Ref}


/*typedefStruct*/
variable_definition:
| variable_definition type_spec IDENTIFIER SEMICOLON { SingleTypeTermWithIdent($3,$2)::$1 }
| {[]}

/*procedure , stmt list*/

/* stmt list */
procedure_body:
| atomic_stmt SEMICOLON rec_procedure_body {$1::$3}
| compound_stmt rec_procedure_body {$1::$2}

rec_procedure_body:
| procedure_body {$1}
| {[]}

/* stmt */
atomic_stmt:
| lvalue EQ_COL rvalue { Assign($1,$3)}
| READ lvalue { Read($2) }
| WRITE expr { Write($2) }
| IDENTIFIER LEFT_PAREN expr_list RIGHT_PAREN { Method($1,$3) }

/* stmt */
compound_stmt:
| IF expr THEN stmt_list else_block FI {IfDec($2,$4,$5)}
| WHILE expr DO stmt_list OD {WhileDec($2,$4)}


/* object.field*/
lvalue:
| IDENTIFIER { LId($1) }
| lvalue DOT IDENTIFIER { LField($1,$3) }

/* rvalue*/
rvalue:
| expr { Rexpr($1) }
| LEFT_BRACE field_init RIGHT_BRACE { Rstmts(List.rev $2) }
| LEFT_BRACE RIGHT_BRACE { Rempty }

/* rvalue list */
field_init:
| rec_field_init IDENTIFIER EQ rvalue {Rassign($2,$4)::$1}

rec_field_init:
| field_init COMMA {$1}
| {[]}

expr:
| lvalue { Elval($1) }
| const { $1 }
| LEFT_PAREN expr RIGHT_PAREN { Ebracket($2) }
| expr PLUS expr { Ebinop($1,Op_add,$3) }
| expr MINUS expr { Ebinop($1,Op_sub,$3) }
| expr MUL expr { Ebinop($1,Op_mul,$3) }
| expr DIV expr { Ebinop($1,Op_div,$3) }
| expr EQ expr { Ebinop($1,Op_eq,$3) }
| expr NEQ expr { Ebinop($1,Op_neq,$3) }
| expr LT expr { Ebinop($1,Op_lt,$3) }
| expr GT expr { Ebinop($1,Op_gt,$3) }
| expr LTE expr { Ebinop($1,Op_lte,$3) }
| expr GTE expr { Ebinop($1,Op_gte,$3) }
| expr AND expr { Ebinop($1,Op_and,$3) }
| expr OR expr { Ebinop($1,Op_or,$3) }
| NOT expr { Eunop(Op_not,$2) }
| UMINUS expr { Eunop(Op_minus,$2) }

/* expr list */
expr_list:
| expr rec_expr_list { $1::$2 }
| {[]}

rec_expr_list:
| COMMA expr_list { $2 }
| {[]}

stmt_list:
| procedure_body {$1}

else_block:
| ELSE stmt_list {$2}
| {[]}

const:
| BOOL_VAL { Ebool($1) }
| INT_VAL { Eint($1) }
| STRING_VAL { Eident($1) }
============================================
src/feedback.txt
02:16:27_Monday_11_April_2016
============================================
============================================
vis/bingfengl.out
02:05:42_Monday_11_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  bingfengl

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc bean_parse.mly
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
90 states, 5239 transitions, table size 21496 bytes
ocamlopt  -g -c bean_lex.ml
ocamlc  -c bean_pprint.mli
ocamlopt  -g -c bean_pprint.ml
ocamlopt  -g -c bean.ml
ocamlopt -g -o bean bean_ast.cmx bean_lex.cmx bean_parse.cmx bean_pprint.cmx bean.cmx

--- Succeeded ---

******************************************   Parsing lex01.bean:

Mismatch:
0a1
> fname => ../data/lex01.bean
5c6
<     x := 2 + 1 - 1 * 1;
---
>     x := 2 + 1 - ( 1 * 1 ) ;
7a9
> 

******************************************   Parsing lex02.bean:

Mismatch:
0a1
> fname => ../data/lex02.bean
11a13
> 

******************************************   Parsing lex03.bean:

Mismatch:
0a1
> fname => ../data/lex03.bean
10a12
> 

******************************************   Parsing lex04.bean:

Mismatch:
0a1
> fname => ../data/lex04.bean
6c7
<     r.c := false;
---
>     c.r := false;
7a9
> 

******************************************   Parsing syn01.bean:

Mismatch:
0a1
> fname => ../data/syn01.bean
6c7
<     write (1 * (2 - 3) + 4 - 3) * 2 * -1;
---
>     write ( ( ( 1 * ( 2 - 3 )  + 4 - 3 )  )  )  * 2 * -1;
8a10
> 

******************************************   Parsing syn02.bean:

Mismatch:
0a1
> fname => ../data/syn02.bean
6a8
> 

******************************************   Parsing prpr1.bean:

Mismatch:
0a1
> fname => ../data/prpr1.bean
23a25
> 

******************************************   Parsing prpr2.bean:

Syntax error
Mismatch:
1,8c1
< 
< proc main()
<     int x;
< 
<     x := -5 + 6;
<     x := -(5 - 2 - 1);
<     x := true and true or true and false;
< end
---
> fname => ../data/prpr2.bean

******************************************   Parsing prpr3.bean:

Mismatch:
0a1
> fname => ../data/prpr3.bean
5c6
<     x := 6 + 3 * 2 + 4 * 5;
---
>     x := 6 + ( ( 3 * 2 )  )  + 4 * 5;
6a8
> 

******************************************   Parsing prpr4.bean:

Mismatch:
0a1
> fname => ../data/prpr4.bean
21a23
> 

******************************************   Parsing prpr5.bean:

Mismatch:
0a1
> fname => ../data/prpr5.bean
6c7
<     p(x, x);
---
>     p(xx);
9c10
<             p(x, x);
---
>             p(xx);
11c12
<                 p(x, x);
---
>                 p(xx);
13c14
<                 p(x, x);
---
>                 p(xx);
17c18
<                 p(x, x);
---
>                 p(xx);
20,21c21
<                     p(x, x);
<                     p(x, x);
---
>                     p(xx);p(xx);
23c23
<                 p(x, x);
---
>                 p(xx);
25c25
<             p(x, x);
---
>             p(xx);
29,30c29
<             p(x, x);
<             p(x, x);
---
>             p(xx);p(xx);
33c32
<             p(x, x);
---
>             p(xx);
35c34
<             p(x, x);
---
>             p(xx);
43a43
> 

******************************************   Parsing prpr6.bean:

Syntax error
Mismatch:
1,41c1
< 
< proc main()
< 
<     p(4);
< end
< 
< proc p()
<     int m;
<     int n;
<     int diff;
< 
<     read m;
<     read n;
<     while m != n do
<         diff := 0;
<         while m * n > 0 do
<             m := m - 1;
<             n := n - 1;
<             diff := diff + 1;
<         od
<         if m != 0 then
<             n := diff;
<         else
<             m := diff;
<         fi
<     od
<     write m;
< end
< 
< proc q()
<     bool x;
< 
<     x := true and true or true and false;
< end
< 
< proc r()
<     int x;
< 
<     x := 6;
<     s(x, x);
< end
---
> fname => ../data/prpr6.bean

******************************************   Parsing bell.bean:

Mismatch:
0a1
> fname => ../data/bell.bean
6c7
<     write "Type integer n: ";
---
>     write "Type integer n: " ;
9c10
<     write "Bell(n) is: ";
---
>     write "Bell(n) is: " ;
11c12
<     write "\n";
---
>     write "\n" ;
29a31
> 

******************************************   Parsing fib.bean:

Mismatch:
0a1
> fname => ../data/fib.bean
6c7
<     write ">";
---
>     write ">" ;
10c11
<     write "\n";
---
>     write "\n" ;
24a26
> 

******************************************   Parsing gcd.bean:

Illegal Character on line 28, col 18.
Mismatch:
1,33c1
< 
< proc main()
<     int x;
<     int y;
<     int temp;
<     int quotient;
<     int remainder;
< 
<     write "Input two positive integers: ";
<     read x;
<     read y;
<     write "\n";
<     if x < y then
<         temp := x;
<         x := y;
<         y := temp;
<     fi
<     write "The gcd of ";
<     write x;
<     write " and ";
<     write y;
<     write " is ";
<     quotient := x / y;
<     remainder := x - quotient * y;
<     while remainder > 0 do
<         x := y;
<         y := remainder;
<         quotient := x / y;
<         remainder := x - quotient * y;
<     od
<     write y;
<     write "\n";
< end
---
> fname => ../data/gcd.bean

******************************************   Parsing hail.bean:

Illegal Character on line 23, col 14.
Mismatch:
1,30c1
< 
< proc main()
<     int n;
<     int result;
< 
<     n := 1;
<     while n < 21 do
<         hail(n, result);
<         write result;
<         write " ";
<         n := n + 1;
<     od
<     write "\n";
< end
< 
< proc hail(val int in, ref int out)
<     int count;
< 
<     count := 1;
<     if in = 1 then
<         out := count;
<     else
<         if in / 2 * 2 = in then
<             hail(in / 2, count);
<         else
<             hail(3 * in + 1, count);
<         fi
<         out := count + 1;
<     fi
< end
---
> fname => ../data/hail.bean

******************************************   Parsing power.bean:

Illegal Character on line 21, col 16.
Mismatch:
1,30c1
< 
< proc main()
<     float x;
<     float result;
<     int n;
< 
<     write "Float x: ";
<     read x;
<     write "Positive integer n: ";
<     read n;
<     power(x, n, result);
<     write "x^n is: ";
<     write result;
<     write "\n";
< end
< 
< proc power(val float x, val int n, ref float out)
<     float res;
< 
<     if n = 1 then
<         out := x;
<     else
<         power(x * x, n / 2, res);
<         if 2 * (n / 2) = n then
<             out := res;
<         else
<             out := x * res;
<         fi
<     fi
< end
---
> fname => ../data/power.bean

******************************************   Parsing stddev.bean:

Syntax error
Mismatch:
1,27c1
< 
< proc main()
<     int x;
<     int sum;
<     int sumsq;
<     int mean;
<     int count;
<     int done;
< 
<     write "Type a list of integers, ending with a negative number\n";
<     read x;
<     done := x < 0;
<     while not done do
<         count := count + 1;
<         sum := sum + x;
<         sumsq := sumsq + x * x;
<         read x;
<         done := x < 0;
<     od
<     mean := sum / count;
<     write "The mean is ";
<     write mean;
<     write "\n";
<     write "The variance is ";
<     write sumsq / count - mean * mean;
<     write "\n";
< end
---
> fname => ../data/stddev.bean

******************************************   Parsing strange.bean:

Mismatch:
0a1
> fname => ../data/strange.bean
9,10c10,11
<     z.fA := 42;
<     z.fB := {fB = true, gA = false};
---
>     fA.z := 42;
>     fB.z := {fB = true, gA = false};
38a40
> 

******************************************   Parsing lex11.bad.bean:
proc main()
int x;
  x := @ ;
end
Result:
fname => ../data/lex11.bad.bean 
Illegal Character on line 3, col 7.

******************************************   Parsing lex12.bad.bean:
proc main()
int x;
int xyz_ab$;
bool z;
    x := 3;
    z := true;
    write z;
end
Result:
fname => ../data/lex12.bad.bean 
Illegal Character on line 3, col 10.

******************************************   Parsing lex13.bad.bean:
proc main()
    int int; int := 0;
end
Result:
fname => ../data/lex13.bad.bean 
Syntax error

******************************************   Parsing syn12.bad.bean:
proc main ()
    bool test; 
end

proc fib(int val n, ref int ref out)
    int f1;
    int f2;

    out := n;
}

Result:
fname => ../data/syn12.bad.bean 
Syntax error

******************************************   Parsing syn13.bad.bean:
proc main()
int x;
int y;
# Sequence of statements cannot be empty
end

Result:
fname => ../data/syn13.bad.bean 
Syntax error

******************************************   Parsing syn14.bad.bean:
proc main()
int m;
int n;
    read n;
    while n>1 do
        m := ( n;
        while m := m do
            if then
                n := n - 1;
                m := m - 1
                if true then m := m - 1; else n := 6*n + 4;
                fi
             fi
        od
    od
end
Result:
fname => ../data/syn14.bad.bean 
Syntax error

******************************************   Parsing syn15.bad.bean:
proc main()
    int x; x := 0; x := 1
end
Result:
fname => ../data/syn15.bad.bean 
Syntax error

******************************************   Parsing syn16.bad.bean:
proc main()
typedef {b: int} t

t a;
    t.b := 0;
end
Result:
fname => ../data/syn16.bad.bean 
Syntax error

******************************************   Parsing syn17.bad.bean:
proc main()
int n;
    n := 0;
end
    n := 1;
Result:
fname => ../data/syn17.bad.bean 
Syntax error

******************************************   Parsing syn18.bad.bean:
proc main()
int m;
int n;
    read m;
    write if m=n then
end
Result:
fname => ../data/syn18.bad.bean 
Syntax error

******************************************   Parsing syn19.bad.bean:
proc main(val int a, ref)
int m; read m;
end
Result:
fname => ../data/syn19.bad.bean 
Syntax error


--- End of testing for bingfengl ---\n

============================================
src/bean_ast.mli
02:05:40_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty

type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)


type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref



type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program
(*
val printBeantype : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit 
val printTypedefs : (typedefStruct list * ident) list -> unit
*)
(*
val printBeanType : beantype -> unit 
val printSingleTypeDef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit 
*)
(*
val printBeanType : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit
val printSingleTypedef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit
*)
(*
val printFuncIndicator : valRef -> unit
val printFuncparams : valRef * typedefStruct * ident -> unit
val printFuncheader : ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : typedefStruct list -> unit
val printLvalue : lvalue -> unit
val printBinop : binop -> unit
val printUnop : unop -> unit
val printExpr : expr -> unit
val printRvalue : rvalue -> unit
val printStmt : stmt -> unit
val printFuncBody : stmt list -> unit
val printSingleFuncdef : (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit 
val printFuncdefList : ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit*)
val printBeanType : Format.formatter -> beantype * string -> unit
val printTypedefStruct : Format.formatter -> int * typedefStruct -> unit
val printSingleTypedef : Format.formatter -> typedefStruct * ident -> unit
val printTypedefList : Format.formatter -> (typedefStruct * ident) list -> unit
val printFuncIndicator : Format.formatter -> valRef -> unit
val printFuncparams : Format.formatter -> valRef * typedefStruct * ident -> unit
val printFuncheader : Format.formatter -> ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : Format.formatter -> typedefStruct list -> unit
val printLvalue : Format.formatter -> lvalue -> unit
val printBinop : Format.formatter -> binop -> unit
val printUnop : Format.formatter -> unop -> unit
val printExpr : Format.formatter -> expr -> unit
val printRvalue : Format.formatter -> rvalue -> unit
val getIdent : int -> ident
val printEndStmt : Format.formatter -> bool -> ident -> unit
val printStmt : Format.formatter -> int * bool * stmt -> unit
val printFuncBody : Format.formatter -> stmt list -> unit
val printSingleFuncdef : Format.formatter -> (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit
val printFuncdefList : Format.formatter -> ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit============================================
src/bean_parse.mly
02:05:40_Monday_11_April_2016
============================================
/* ocamlyacc parser for bean */
%{
open Bean_ast
%}

%token <bool> BOOL_VAL
%token <int> INT_VAL
%token <string> STRING_VAL
%token WRITE READ
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token PLUS MINUS MUL DIV
%token UMINUS
%token COLON
%token SEMICOLON
%token AND OR NOT
%token EOF


%token <string> IDENTIFIER
%token LEFT_PAREN RIGHT_PAREN
%token <string> TYPEDEF
%token TYPEDEF_VALUE_INIT
%token DOT
%token COMMA
%token END
%token VAL
%token REF
%token LEFT_BRACE RIGHT_BRACE
%token WHILE DO OD
%token IF THEN ELSE FI
%token BOOL INT
%token PROC
%token EQ_COL
%left OR
%left AND
%nonassoc EQ NEQ LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right EQ_COL
%nonassoc NOT UMINUS

%type <Bean_ast.program> start_state

%start start_state
%%


/*
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
*/

start_state:
| type_definition procedure_definition {{typedefs = List.rev $1;funcdefs = List.rev $2}}

/*typdef ? identifier*/
type_definition:
| type_definition TYPEDEF type_spec IDENTIFIER {($3,$4)::$1}
| {[]}

type_spec:
| primitive_type {$1}
| IDENTIFIER {SingleTypeTerm((IdentType $1))}
/*typdef {?} identifier*/
| LEFT_BRACE field_definition RIGHT_BRACE {ListTypeTerm( List.rev $2)}

primitive_type:
| BOOL {SingleTypeTerm(Bool)}
| INT {SingleTypeTerm(Int)}

field_definition:
| rec_field_definition IDENTIFIER COLON type_spec {SingleTypeTermWithIdent($2,$4)::$1}

rec_field_definition:
| field_definition COMMA {$1}
| {[]}








/* At least one procedure required */
/* (functionDeclaration * typedefStruct  * stmt list) list */
procedure_definition:
| rec_procedure_definition PROC procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}

/* (functionDeclaration * typedefStruct  * stmt list) list */
rec_procedure_definition:
| procedure_definition {$1}
| {[]}

/*type functionDeclaration = (string*funcDecParamList)*/
/*type funcDecParamList = (valRef*typedefStruct*string) list*/
procedure_header:
| IDENTIFIER LEFT_PAREN param RIGHT_PAREN {($1,List.rev $3)}


/*type funcDecParamList = (valRef*typedefStruct*string) list*/
param:
| rec_param param_passing_indicator type_spec IDENTIFIER {($2,$3,$4)::$1}
| {[]}

/*type funcDecParamList = (valRef*typedefStruct*string)*/

rec_param:
| param COMMA {$1}
| {[]}

/* type valRef  */
param_passing_indicator:
| VAL {Val}
| REF {Ref}


/*typedefStruct*/
variable_definition:
| variable_definition type_spec IDENTIFIER SEMICOLON { SingleTypeTermWithIdent($3,$2)::$1 }
| {[]}

/*procedure , stmt list*/

/* stmt list */
procedure_body:
| atomic_stmt SEMICOLON rec_procedure_body {$1::$3}
| compound_stmt rec_procedure_body {$1::$2}

rec_procedure_body:
| procedure_body {$1}
| {[]}

/* stmt */
atomic_stmt:
| lvalue EQ_COL rvalue { Assign($1,$3)}
| READ lvalue { Read($2) }
| WRITE expr { Write($2) }
| IDENTIFIER LEFT_PAREN expr_list RIGHT_PAREN { Method($1,$3) }

/* stmt */
compound_stmt:
| IF expr THEN stmt_list else_block FI {IfDec($2,$4,$5)}
| WHILE expr DO stmt_list OD {WhileDec($2,$4)}


/* object.field*/
lvalue:
| IDENTIFIER { LId($1) }
| lvalue DOT IDENTIFIER { LField($1,$3) }

/* rvalue*/
rvalue:
| expr { Rexpr($1) }
| LEFT_BRACE field_init RIGHT_BRACE { Rstmts(List.rev $2) }
| LEFT_BRACE RIGHT_BRACE { Rempty }

/* rvalue list */
field_init:
| rec_field_init IDENTIFIER EQ rvalue {Rassign($2,$4)::$1}

rec_field_init:
| field_init COMMA {$1}
| {[]}

expr:
| lvalue { Elval($1) }
| const { $1 }
| LEFT_PAREN expr RIGHT_PAREN { Ebracket($2) }
| expr PLUS expr { Ebinop($1,Op_add,$3) }
| expr MINUS expr { Ebinop($1,Op_sub,$3) }
| expr MUL expr { Ebinop($1,Op_mul,$3) }
| expr DIV expr { Ebinop($1,Op_div,$3) }
| expr EQ expr { Ebinop($1,Op_eq,$3) }
| expr NEQ expr { Ebinop($1,Op_neq,$3) }
| expr LT expr { Ebinop($1,Op_lt,$3) }
| expr GT expr { Ebinop($1,Op_gt,$3) }
| expr LTE expr { Ebinop($1,Op_lte,$3) }
| expr GTE expr { Ebinop($1,Op_gte,$3) }
| expr AND expr { Ebinop($1,Op_and,$3) }
| expr OR expr { Ebinop($1,Op_or,$3) }
| NOT expr { Eunop(Op_not,$2) }
| UMINUS expr { Eunop(Op_minus,$2) }

/* expr list */
expr_list:
| expr rec_expr_list { $1::$2 }
| {[]}

rec_expr_list:
| COMMA expr_list { $2 }
| {[]}

stmt_list:
| procedure_body {$1}

else_block:
| ELSE stmt_list {$2}
| {[]}

const:
| BOOL_VAL { Ebool($1) }
| INT_VAL { Eint($1) }
| STRING_VAL { Eident($1) }
============================================
src/Makefile.depend
02:05:40_Monday_11_April_2016
============================================
bean.cmo :
bean.cmx :
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi :
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_pprint.cmi
bean_pprint.cmx : bean_pprint.cmi
bean.cmo :
bean.cmx :
============================================
src/Makefile
02:05:40_Monday_11_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o ./bean *.byte
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/feedback.txt
02:05:40_Monday_11_April_2016
============================================
============================================
vis/bingfengl.out
02:04:22_Monday_11_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  bingfengl

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc bean_parse.mly
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
90 states, 5239 transitions, table size 21496 bytes
ocamlopt  -g -c bean_lex.ml
ocamlc  -c bean_pprint.mli
ocamlopt  -g -c bean_pprint.ml
ocamlopt  -g -c bean.ml
ocamlopt -g -o bean bean_ast.cmx bean_lex.cmx bean_parse.cmx bean_pprint.cmx bean.cmx

--- Succeeded ---

******************************************   Parsing lex01.bean:

Mismatch:
0a1,3
> fname => ../data/lex01.bean
> 
> what is in side =>
5c8
<     x := 2 + 1 - 1 * 1;
---
>     x := 2 + 1 - ( 1 * 1 ) ;
7a11
> 

******************************************   Parsing lex02.bean:

Mismatch:
0a1,3
> fname => ../data/lex02.bean
> 
> what is in side =>
11a15
> 

******************************************   Parsing lex03.bean:

Mismatch:
0a1,3
> fname => ../data/lex03.bean
> 
> what is in side =>
10a14
> 

******************************************   Parsing lex04.bean:

Mismatch:
0a1,3
> fname => ../data/lex04.bean
> 
> what is in side =>
6c9
<     r.c := false;
---
>     c.r := false;
7a11
> 

******************************************   Parsing syn01.bean:

Mismatch:
0a1,3
> fname => ../data/syn01.bean
> 
> what is in side =>
6c9
<     write (1 * (2 - 3) + 4 - 3) * 2 * -1;
---
>     write ( ( ( 1 * ( 2 - 3 )  + 4 - 3 )  )  )  * 2 * -1;
8a12
> 

******************************************   Parsing syn02.bean:

Mismatch:
0a1,3
> fname => ../data/syn02.bean
> 
> what is in side =>
6a10
> 

******************************************   Parsing prpr1.bean:

Mismatch:
0a1,3
> fname => ../data/prpr1.bean
> 
> what is in side =>
23a27
> 

******************************************   Parsing prpr2.bean:

Syntax error
Mismatch:
1,8c1
< 
< proc main()
<     int x;
< 
<     x := -5 + 6;
<     x := -(5 - 2 - 1);
<     x := true and true or true and false;
< end
---
> fname => ../data/prpr2.bean

******************************************   Parsing prpr3.bean:

Mismatch:
0a1,3
> fname => ../data/prpr3.bean
> 
> what is in side =>
5c8
<     x := 6 + 3 * 2 + 4 * 5;
---
>     x := 6 + ( ( 3 * 2 )  )  + 4 * 5;
6a10
> 

******************************************   Parsing prpr4.bean:

Mismatch:
0a1,3
> fname => ../data/prpr4.bean
> 
> what is in side =>
21a25
> 

******************************************   Parsing prpr5.bean:

Mismatch:
0a1,3
> fname => ../data/prpr5.bean
> 
> what is in side =>
6c9
<     p(x, x);
---
>     p(xx);
9c12
<             p(x, x);
---
>             p(xx);
11c14
<                 p(x, x);
---
>                 p(xx);
13c16
<                 p(x, x);
---
>                 p(xx);
17c20
<                 p(x, x);
---
>                 p(xx);
20,21c23
<                     p(x, x);
<                     p(x, x);
---
>                     p(xx);p(xx);
23c25
<                 p(x, x);
---
>                 p(xx);
25c27
<             p(x, x);
---
>             p(xx);
29,30c31
<             p(x, x);
<             p(x, x);
---
>             p(xx);p(xx);
33c34
<             p(x, x);
---
>             p(xx);
35c36
<             p(x, x);
---
>             p(xx);
43a45
> 

******************************************   Parsing prpr6.bean:

Syntax error
Mismatch:
1,41c1
< 
< proc main()
< 
<     p(4);
< end
< 
< proc p()
<     int m;
<     int n;
<     int diff;
< 
<     read m;
<     read n;
<     while m != n do
<         diff := 0;
<         while m * n > 0 do
<             m := m - 1;
<             n := n - 1;
<             diff := diff + 1;
<         od
<         if m != 0 then
<             n := diff;
<         else
<             m := diff;
<         fi
<     od
<     write m;
< end
< 
< proc q()
<     bool x;
< 
<     x := true and true or true and false;
< end
< 
< proc r()
<     int x;
< 
<     x := 6;
<     s(x, x);
< end
---
> fname => ../data/prpr6.bean

******************************************   Parsing bell.bean:

Mismatch:
0a1,3
> fname => ../data/bell.bean
> 
> what is in side =>
6c9
<     write "Type integer n: ";
---
>     write "Type integer n: " ;
9c12
<     write "Bell(n) is: ";
---
>     write "Bell(n) is: " ;
11c14
<     write "\n";
---
>     write "\n" ;
29a33
> 

******************************************   Parsing fib.bean:

Mismatch:
0a1,3
> fname => ../data/fib.bean
> 
> what is in side =>
6c9
<     write ">";
---
>     write ">" ;
10c13
<     write "\n";
---
>     write "\n" ;
24a28
> 

******************************************   Parsing gcd.bean:

Illegal Character on line 28, col 18.
Mismatch:
1,33c1
< 
< proc main()
<     int x;
<     int y;
<     int temp;
<     int quotient;
<     int remainder;
< 
<     write "Input two positive integers: ";
<     read x;
<     read y;
<     write "\n";
<     if x < y then
<         temp := x;
<         x := y;
<         y := temp;
<     fi
<     write "The gcd of ";
<     write x;
<     write " and ";
<     write y;
<     write " is ";
<     quotient := x / y;
<     remainder := x - quotient * y;
<     while remainder > 0 do
<         x := y;
<         y := remainder;
<         quotient := x / y;
<         remainder := x - quotient * y;
<     od
<     write y;
<     write "\n";
< end
---
> fname => ../data/gcd.bean

******************************************   Parsing hail.bean:

Illegal Character on line 23, col 14.
Mismatch:
1,30c1
< 
< proc main()
<     int n;
<     int result;
< 
<     n := 1;
<     while n < 21 do
<         hail(n, result);
<         write result;
<         write " ";
<         n := n + 1;
<     od
<     write "\n";
< end
< 
< proc hail(val int in, ref int out)
<     int count;
< 
<     count := 1;
<     if in = 1 then
<         out := count;
<     else
<         if in / 2 * 2 = in then
<             hail(in / 2, count);
<         else
<             hail(3 * in + 1, count);
<         fi
<         out := count + 1;
<     fi
< end
---
> fname => ../data/hail.bean

******************************************   Parsing power.bean:

Illegal Character on line 21, col 16.
Mismatch:
1,30c1
< 
< proc main()
<     float x;
<     float result;
<     int n;
< 
<     write "Float x: ";
<     read x;
<     write "Positive integer n: ";
<     read n;
<     power(x, n, result);
<     write "x^n is: ";
<     write result;
<     write "\n";
< end
< 
< proc power(val float x, val int n, ref float out)
<     float res;
< 
<     if n = 1 then
<         out := x;
<     else
<         power(x * x, n / 2, res);
<         if 2 * (n / 2) = n then
<             out := res;
<         else
<             out := x * res;
<         fi
<     fi
< end
---
> fname => ../data/power.bean

******************************************   Parsing stddev.bean:

Syntax error
Mismatch:
1,27c1
< 
< proc main()
<     int x;
<     int sum;
<     int sumsq;
<     int mean;
<     int count;
<     int done;
< 
<     write "Type a list of integers, ending with a negative number\n";
<     read x;
<     done := x < 0;
<     while not done do
<         count := count + 1;
<         sum := sum + x;
<         sumsq := sumsq + x * x;
<         read x;
<         done := x < 0;
<     od
<     mean := sum / count;
<     write "The mean is ";
<     write mean;
<     write "\n";
<     write "The variance is ";
<     write sumsq / count - mean * mean;
<     write "\n";
< end
---
> fname => ../data/stddev.bean

******************************************   Parsing strange.bean:

Mismatch:
0a1,3
> fname => ../data/strange.bean
> 
> what is in side =>
9,10c12,13
<     z.fA := 42;
<     z.fB := {fB = true, gA = false};
---
>     fA.z := 42;
>     fB.z := {fB = true, gA = false};
38a42
> 

******************************************   Parsing lex11.bad.bean:
proc main()
int x;
  x := @ ;
end
Result:
fname => ../data/lex11.bad.bean 
Illegal Character on line 3, col 7.

******************************************   Parsing lex12.bad.bean:
proc main()
int x;
int xyz_ab$;
bool z;
    x := 3;
    z := true;
    write z;
end
Result:
fname => ../data/lex12.bad.bean 
Illegal Character on line 3, col 10.

******************************************   Parsing lex13.bad.bean:
proc main()
    int int; int := 0;
end
Result:
fname => ../data/lex13.bad.bean 
Syntax error

******************************************   Parsing syn12.bad.bean:
proc main ()
    bool test; 
end

proc fib(int val n, ref int ref out)
    int f1;
    int f2;

    out := n;
}

Result:
fname => ../data/syn12.bad.bean 
Syntax error

******************************************   Parsing syn13.bad.bean:
proc main()
int x;
int y;
# Sequence of statements cannot be empty
end

Result:
fname => ../data/syn13.bad.bean 
Syntax error

******************************************   Parsing syn14.bad.bean:
proc main()
int m;
int n;
    read n;
    while n>1 do
        m := ( n;
        while m := m do
            if then
                n := n - 1;
                m := m - 1
                if true then m := m - 1; else n := 6*n + 4;
                fi
             fi
        od
    od
end
Result:
fname => ../data/syn14.bad.bean 
Syntax error

******************************************   Parsing syn15.bad.bean:
proc main()
    int x; x := 0; x := 1
end
Result:
fname => ../data/syn15.bad.bean 
Syntax error

******************************************   Parsing syn16.bad.bean:
proc main()
typedef {b: int} t

t a;
    t.b := 0;
end
Result:
fname => ../data/syn16.bad.bean 
Syntax error

******************************************   Parsing syn17.bad.bean:
proc main()
int n;
    n := 0;
end
    n := 1;
Result:
fname => ../data/syn17.bad.bean 
Syntax error

******************************************   Parsing syn18.bad.bean:
proc main()
int m;
int n;
    read m;
    write if m=n then
end
Result:
fname => ../data/syn18.bad.bean 
Syntax error

******************************************   Parsing syn19.bad.bean:
proc main(val int a, ref)
int m; read m;
end
Result:
fname => ../data/syn19.bad.bean 
Syntax error


--- End of testing for bingfengl ---\n

============================================
src/bean_ast.mli
02:04:20_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty

type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)


type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref



type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program
(*
val printBeantype : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit 
val printTypedefs : (typedefStruct list * ident) list -> unit
*)
(*
val printBeanType : beantype -> unit 
val printSingleTypeDef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit 
*)
(*
val printBeanType : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit
val printSingleTypedef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit
*)
(*
val printFuncIndicator : valRef -> unit
val printFuncparams : valRef * typedefStruct * ident -> unit
val printFuncheader : ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : typedefStruct list -> unit
val printLvalue : lvalue -> unit
val printBinop : binop -> unit
val printUnop : unop -> unit
val printExpr : expr -> unit
val printRvalue : rvalue -> unit
val printStmt : stmt -> unit
val printFuncBody : stmt list -> unit
val printSingleFuncdef : (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit 
val printFuncdefList : ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit*)
val printBeanType : Format.formatter -> beantype * string -> unit
val printTypedefStruct : Format.formatter -> int * typedefStruct -> unit
val printSingleTypedef : Format.formatter -> typedefStruct * ident -> unit
val printTypedefList : Format.formatter -> (typedefStruct * ident) list -> unit
val printFuncIndicator : Format.formatter -> valRef -> unit
val printFuncparams : Format.formatter -> valRef * typedefStruct * ident -> unit
val printFuncheader : Format.formatter -> ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : Format.formatter -> typedefStruct list -> unit
val printLvalue : Format.formatter -> lvalue -> unit
val printBinop : Format.formatter -> binop -> unit
val printUnop : Format.formatter -> unop -> unit
val printExpr : Format.formatter -> expr -> unit
val printRvalue : Format.formatter -> rvalue -> unit
val getIdent : int -> ident
val printEndStmt : Format.formatter -> bool -> ident -> unit
val printStmt : Format.formatter -> int * bool * stmt -> unit
val printFuncBody : Format.formatter -> stmt list -> unit
val printSingleFuncdef : Format.formatter -> (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit
val printFuncdefList : Format.formatter -> ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit============================================
src/bean_pprint.mli
02:04:20_Monday_11_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/bean_parse.mly
02:04:20_Monday_11_April_2016
============================================
/* ocamlyacc parser for bean */
%{
open Bean_ast
%}

%token <bool> BOOL_VAL
%token <int> INT_VAL
%token <string> STRING_VAL
%token WRITE READ
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token PLUS MINUS MUL DIV
%token UMINUS
%token COLON
%token SEMICOLON
%token AND OR NOT
%token EOF


%token <string> IDENTIFIER
%token LEFT_PAREN RIGHT_PAREN
%token <string> TYPEDEF
%token TYPEDEF_VALUE_INIT
%token DOT
%token COMMA
%token END
%token VAL
%token REF
%token LEFT_BRACE RIGHT_BRACE
%token WHILE DO OD
%token IF THEN ELSE FI
%token BOOL INT
%token PROC
%token EQ_COL
%left OR
%left AND
%nonassoc EQ NEQ LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right EQ_COL
%nonassoc NOT UMINUS

%type <Bean_ast.program> start_state

%start start_state
%%


/*
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
*/

start_state:
| type_definition procedure_definition {{typedefs = List.rev $1;funcdefs = List.rev $2}}

/*typdef ? identifier*/
type_definition:
| type_definition TYPEDEF type_spec IDENTIFIER {($3,$4)::$1}
| {[]}

type_spec:
| primitive_type {$1}
| IDENTIFIER {SingleTypeTerm((IdentType $1))}
/*typdef {?} identifier*/
| LEFT_BRACE field_definition RIGHT_BRACE {ListTypeTerm( List.rev $2)}

primitive_type:
| BOOL {SingleTypeTerm(Bool)}
| INT {SingleTypeTerm(Int)}

field_definition:
| rec_field_definition IDENTIFIER COLON type_spec {SingleTypeTermWithIdent($2,$4)::$1}

rec_field_definition:
| field_definition COMMA {$1}
| {[]}








/* At least one procedure required */
/* (functionDeclaration * typedefStruct  * stmt list) list */
procedure_definition:
| rec_procedure_definition PROC procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}

/* (functionDeclaration * typedefStruct  * stmt list) list */
rec_procedure_definition:
| procedure_definition {$1}
| {[]}

/*type functionDeclaration = (string*funcDecParamList)*/
/*type funcDecParamList = (valRef*typedefStruct*string) list*/
procedure_header:
| IDENTIFIER LEFT_PAREN param RIGHT_PAREN {($1,List.rev $3)}


/*type funcDecParamList = (valRef*typedefStruct*string) list*/
param:
| rec_param param_passing_indicator type_spec IDENTIFIER {($2,$3,$4)::$1}
| {[]}

/*type funcDecParamList = (valRef*typedefStruct*string)*/

rec_param:
| param COMMA {$1}
| {[]}

/* type valRef  */
param_passing_indicator:
| VAL {Val}
| REF {Ref}


/*typedefStruct*/
variable_definition:
| variable_definition type_spec IDENTIFIER SEMICOLON { SingleTypeTermWithIdent($3,$2)::$1 }
| {[]}

/*procedure , stmt list*/

/* stmt list */
procedure_body:
| atomic_stmt SEMICOLON rec_procedure_body {$1::$3}
| compound_stmt rec_procedure_body {$1::$2}

rec_procedure_body:
| procedure_body {$1}
| {[]}

/* stmt */
atomic_stmt:
| lvalue EQ_COL rvalue { Assign($1,$3)}
| READ lvalue { Read($2) }
| WRITE expr { Write($2) }
| IDENTIFIER LEFT_PAREN expr_list RIGHT_PAREN { Method($1,$3) }

/* stmt */
compound_stmt:
| IF expr THEN stmt_list else_block FI {IfDec($2,$4,$5)}
| WHILE expr DO stmt_list OD {WhileDec($2,$4)}


/* object.field*/
lvalue:
| IDENTIFIER { LId($1) }
| lvalue DOT IDENTIFIER { LField($1,$3) }

/* rvalue*/
rvalue:
| expr { Rexpr($1) }
| LEFT_BRACE field_init RIGHT_BRACE { Rstmts(List.rev $2) }
| LEFT_BRACE RIGHT_BRACE { Rempty }

/* rvalue list */
field_init:
| rec_field_init IDENTIFIER EQ rvalue {Rassign($2,$4)::$1}

rec_field_init:
| field_init COMMA {$1}
| {[]}

expr:
| lvalue { Elval($1) }
| const { $1 }
| LEFT_PAREN expr RIGHT_PAREN { Ebracket($2) }
| expr PLUS expr { Ebinop($1,Op_add,$3) }
| expr MINUS expr { Ebinop($1,Op_sub,$3) }
| expr MUL expr { Ebinop($1,Op_mul,$3) }
| expr DIV expr { Ebinop($1,Op_div,$3) }
| expr EQ expr { Ebinop($1,Op_eq,$3) }
| expr NEQ expr { Ebinop($1,Op_neq,$3) }
| expr LT expr { Ebinop($1,Op_lt,$3) }
| expr GT expr { Ebinop($1,Op_gt,$3) }
| expr LTE expr { Ebinop($1,Op_lte,$3) }
| expr GTE expr { Ebinop($1,Op_gte,$3) }
| expr AND expr { Ebinop($1,Op_and,$3) }
| expr OR expr { Ebinop($1,Op_or,$3) }
| NOT expr { Eunop(Op_not,$2) }
| UMINUS expr { Eunop(Op_minus,$2) }

/* expr list */
expr_list:
| expr rec_expr_list { $1::$2 }
| {[]}

rec_expr_list:
| COMMA expr_list { $2 }
| {[]}

stmt_list:
| procedure_body {$1}

else_block:
| ELSE stmt_list {$2}
| {[]}

const:
| BOOL_VAL { Ebool($1) }
| INT_VAL { Eint($1) }
| STRING_VAL { Eident($1) }
============================================
src/bean_ast.ml
02:04:20_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty


type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)




type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref


type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program

(*
let printBeantype beanTypeData = match beanTypeData with
| Bool -> Printf.printf " Bool "
| Int -> Printf.printf " Int "
| IdentType(s) ->  Printf.printf " string => %s" s

let rec printTypedefStruct typedefStructData = match typedefStructData with
| SingleTypeTerm(id , tp) -> (Printf.printf "id => %s , type => \n" id ; printBeantype tp)
| ListTypeTerm(id , tps) -> (Printf.printf "Listype name => %s " id;List.iter (printTypedefStruct) tps)

let rec printTypedefs typedefData = match typedefData with
| [] -> Printf.printf "Empty \n "
| (hstructList,hid)::t -> ( Printf.printf "typedef name => %s : \n  " hid; List.iter (printTypedefStruct) hstructList ; printTypedefs t )

*)

(* Print typedef *)

let printBeanType fmt (btype,suffix) =  match btype with
| Bool -> Format.fprintf fmt "bool%s" suffix 
| Int ->  Format.fprintf fmt "int%s" suffix  
| IdentType(ident) -> Format.fprintf fmt "%s%s" ident suffix

(* mode = 1 ==> in typedef *)
let rec printTypedefStruct fmt (arrangeMode,typedefStructData) = match typedefStructData with
| SingleTypeTerm (btype) -> if arrangeMode = 1 then printBeanType fmt (btype,"") else printBeanType fmt (btype," ")
| SingleTypeTermWithIdent (ident,nestTypedefStructData) ->
  if arrangeMode = 1 then Format.fprintf fmt "%s : %a" ident printTypedefStruct (arrangeMode,nestTypedefStructData)
  else Format.fprintf fmt "%a%s" printTypedefStruct (arrangeMode,nestTypedefStructData) ident
| ListTypeTerm (listTypedefStructData) ->(Format.fprintf fmt "{"  ;
  List.iter (fun x -> if x = List.nth listTypedefStructData ((List.length listTypedefStructData)-1) 
    then printTypedefStruct fmt (arrangeMode,x)
    else (printTypedefStruct fmt (arrangeMode,x) ; Format.fprintf fmt ", ")) listTypedefStructData;
  Format.fprintf fmt "}" )
| TypedefEnd -> Format.fprintf fmt "end with type def \n"

let printSingleTypedef fmt singleTypedefData = let arrangeMode = 1 in match singleTypedefData with
| (typedefStruct,ident) -> Format.fprintf fmt "typedef %a %s\n" printTypedefStruct (arrangeMode,typedefStruct) ident 
 

let printTypedefList fmt typedefDataList = (Format.fprintf fmt "@[";
  List.iter (printSingleTypedef fmt) typedefDataList;
  Format.fprintf fmt "@]@.")




(* Print method delc*)


let printFuncIndicator fmt funcIndicator = match funcIndicator with
| Val -> Format.fprintf fmt "val "
| Ref -> Format.fprintf fmt "ref "

let printFuncparams fmt singleFuncparamData =  let arrangeMode = 1 in match singleFuncparamData with
| (funcIndicator,typedefStruct,ident) -> Format.fprintf fmt  "%a%a %s"  printFuncIndicator funcIndicator printTypedefStruct (arrangeMode,typedefStruct) ident

let printFuncheader fmt funcheaderData = match funcheaderData with
| (funcname,funcparams) -> (Format.fprintf fmt "%s(" funcname ;
List.iter (fun x -> if x = List.nth funcparams ((List.length funcparams)-1) 
    then printFuncparams fmt x
    else (printFuncparams fmt x ; Format.fprintf fmt ", ")) funcparams;
    Format.fprintf fmt ")")


let printFuncVardef fmt funcVardefData = let arrangeMode = 2 in List.iter (fun x -> 
   if x = List.nth funcVardefData ((List.length funcVardefData)-1)
   then (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";")
   else (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";@ "))
  funcVardefData


(*//TODO *)
let rec printLvalue fmt singleLvalue = match singleLvalue with
| LId(ident) -> Format.fprintf fmt "%s" ident
| LField(recLvalue,ident) -> (Format.fprintf fmt "%s." ident; printLvalue fmt recLvalue)
| LvalueNone -> Format.fprintf fmt "Empty lvalue"

let printBinop fmt singleBinop = match singleBinop with
| Op_add -> Format.fprintf fmt  " + "
| Op_sub -> Format.fprintf fmt  " - "
| Op_mul -> Format.fprintf fmt  " * "
| Op_div -> Format.fprintf fmt " / " 
| Op_eq -> Format.fprintf fmt  " = "
| Op_lt -> Format.fprintf fmt  " < "
| Op_gt -> Format.fprintf fmt  " > "
| Op_neq -> Format.fprintf fmt  " != "
| Op_lte -> Format.fprintf fmt  " <= "
| Op_gte -> Format.fprintf fmt  " >= "
| Op_and -> Format.fprintf fmt  " and "
| Op_or -> Format.fprintf fmt  " or "

let printUnop fmt singleUnop = match singleUnop with
| Op_minus -> Format.fprintf fmt "-"
| Op_not -> Format.fprintf fmt "!"

let rec printExpr fmt singleExpr = match singleExpr with
| Ebool(bool_val) -> Format.fprintf fmt "%B" bool_val
| Eint(int_val) -> Format.fprintf fmt "%d" int_val
| Elval(lvalue) -> printLvalue fmt lvalue
| Ebinop(expr_one,binop,expr_two) -> (printExpr fmt expr_one;
  printBinop fmt binop; printExpr fmt expr_two)
| Eunop(unop,expr) -> (printUnop fmt unop ; printExpr fmt expr)
| Eident(ident) -> Format.fprintf fmt "%s " ident
| Ebracket(expr) -> (Format.fprintf fmt "( " ; printExpr fmt expr  ;Format.fprintf fmt " ) ")


let rec printRvalue fmt singleRvalue = match singleRvalue with
| Rexpr(expr) -> printExpr fmt expr
| RField(rvalue,expr) -> (printRvalue fmt rvalue;
  printExpr fmt expr)
| Rassign(str,rvalue) -> (Format.fprintf fmt "%s = " str;
  printRvalue fmt rvalue)
| Rstmts(rvalueList) -> (Format.fprintf fmt "{";
  List.iter (fun x ->( if x = List.nth rvalueList ((List.length rvalueList)-1) 
  then printRvalue fmt x
  else (printRvalue fmt x ;Format.fprintf fmt ", ") )) rvalueList;
  Format.fprintf fmt "}")
| Rempty -> Format.fprintf fmt "Empty Rvalue "

let getIdent identNum = String.make identNum ' '

let printEndStmt fmt isLast lastStr = match isLast with
  | true -> Format.fprintf fmt  "%s" lastStr
  | false -> Format.fprintf fmt  "%s@ " lastStr

let rec printStmt fmt (initIdent,isLast,singleStmt) = match singleStmt with

| Assign(lvalue, rvalue) -> (printLvalue fmt lvalue;
  Format.fprintf fmt  " := ";
  printRvalue fmt rvalue;
  printEndStmt fmt isLast ";")

| AssignRvalueList(lvalue,rvalueList) ->(printLvalue fmt lvalue;
  Format.fprintf fmt  "={";
  List.iter (printRvalue fmt) rvalueList;
  Format.fprintf fmt "}";
  printEndStmt fmt isLast ";")

| Read(lvalue) -> (Format.fprintf fmt  "read ";
  printLvalue fmt lvalue;
  printEndStmt fmt isLast ";")

| Write(expr) -> (Format.fprintf fmt  "write ";
  printExpr fmt expr;
  printEndStmt fmt isLast ";")

| StmtNone -> Format.fprintf fmt "StmtNone"

| Method(methodname, paramList) -> (Format.fprintf fmt "%s(" methodname ;
  List.iter (fun x -> if x = List.nth paramList ((List.length paramList)-1) 
  then printExpr fmt x
  else (printExpr fmt x; Format.fprintf fmt ", " )) paramList;
  Format.fprintf fmt ")";
  printEndStmt fmt isLast ";")

| VarDec(beantype, ident) -> (printBeanType fmt (beantype,"");
  Format.fprintf fmt "%s " ident;
  printEndStmt fmt isLast ";")

| WhileDec(expr, stmtList) ->(Format.fprintf fmt "while %a do @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth stmtList ((List.length stmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) stmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt"@ od";
  printEndStmt fmt isLast "")

| IfDec(expr, thenStmtList, elseStmtList) -> (Format.fprintf fmt "if %a then @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth thenStmtList ((List.length thenStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) thenStmtList;
  Format.fprintf fmt " @]";
  if (List.length elseStmtList) != 0 then (Format.fprintf fmt " @ ";Format.fprintf fmt "else @ ");
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth elseStmtList ((List.length elseStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) elseStmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt  "@ fi";
  printEndStmt fmt isLast "")

let printFuncBody fmt funcBodyData = let initIdentFactor = 4 in List.iter (fun x -> if x = List.nth funcBodyData ((List.length funcBodyData)-1) 
    then printStmt fmt (initIdentFactor,true,x)
    else printStmt fmt (initIdentFactor,false,x)) funcBodyData
(*
let printSingleFuncdef fmt initIdent initIdentFactor singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) -> Format.fprintf fmt "@[proc %a @ %a @ @ %a end@]@." printFuncheader (initIdent,initIdentFactor,funcheader) printFuncVardef (initIdent,initIdentFactor,funcvardef)  printFuncBody (initIdent,initIdentFactor,funcbody)
*)
let printSingleFuncdef fmt singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) ->(Format.fprintf fmt "proc %a" printFuncheader funcheader;
  if (List.length funcvardef) !=0 then Format.fprintf fmt " @ %a " printFuncVardef funcvardef;
  if (List.length funcbody) != 0 then Format.fprintf fmt " @ @ %a " printFuncBody funcbody;
  Format.fprintf fmt "\nend\n\n")

let printFuncdefList fmt funcdefDataList = let iniIdent = 4 in (Format.fprintf fmt "@[<v %d>" iniIdent ; List.iter (printSingleFuncdef fmt) funcdefDataList ;Format.fprintf fmt "@] " )









============================================
src/feedback.txt
02:04:20_Monday_11_April_2016
============================================
============================================
vis/bingfengl.out
02:03:14_Monday_11_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  bingfengl

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc bean_parse.mly
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
90 states, 5239 transitions, table size 21496 bytes
ocamlopt  -g -c bean_lex.ml
File "bean_lex.mll", line 74, characters 19-22:
Warning S: this expression should have type unit.
ocamlc  -c bean_pprint.mli
ocamlopt  -g -c bean_pprint.ml
ocamlopt  -g -c bean.ml
ocamlopt -g -o bean bean_ast.cmx bean_lex.cmx bean_parse.cmx bean_pprint.cmx bean.cmx

--- Succeeded ---

******************************************   Parsing lex01.bean:

Mismatch:
0a1,3
> fname => ../data/lex01.bean
> 
> what is in side =>
5c8
<     x := 2 + 1 - 1 * 1;
---
>     x := 2 + 1 - ( 1 * 1 ) ;
7a11
> 

******************************************   Parsing lex02.bean:

Mismatch:
0a1,3
> fname => ../data/lex02.bean
> 
> what is in side =>
11a15
> 

******************************************   Parsing lex03.bean:

Mismatch:
0a1,3
> fname => ../data/lex03.bean
> 
> what is in side =>
10a14
> 

******************************************   Parsing lex04.bean:

Mismatch:
0a1,3
> fname => ../data/lex04.bean
> 
> what is in side =>
6c9
<     r.c := false;
---
>     c.r := false;
7a11
> 

******************************************   Parsing syn01.bean:

Mismatch:
0a1,3
> fname => ../data/syn01.bean
> 
> what is in side =>
6c9
<     write (1 * (2 - 3) + 4 - 3) * 2 * -1;
---
>     write ( ( ( 1 * ( 2 - 3 )  + 4 - 3 )  )  )  * 2 * -1;
8a12
> 

******************************************   Parsing syn02.bean:

Mismatch:
0a1,3
> fname => ../data/syn02.bean
> 
> what is in side =>
6a10
> 

******************************************   Parsing prpr1.bean:

Mismatch:
0a1,3
> fname => ../data/prpr1.bean
> 
> what is in side =>
23a27
> 

******************************************   Parsing prpr2.bean:

Syntax error
Mismatch:
1,8c1
< 
< proc main()
<     int x;
< 
<     x := -5 + 6;
<     x := -(5 - 2 - 1);
<     x := true and true or true and false;
< end
---
> fname => ../data/prpr2.bean

******************************************   Parsing prpr3.bean:

Mismatch:
0a1,3
> fname => ../data/prpr3.bean
> 
> what is in side =>
5c8
<     x := 6 + 3 * 2 + 4 * 5;
---
>     x := 6 + ( ( 3 * 2 )  )  + 4 * 5;
6a10
> 

******************************************   Parsing prpr4.bean:

Mismatch:
0a1,3
> fname => ../data/prpr4.bean
> 
> what is in side =>
21a25
> 

******************************************   Parsing prpr5.bean:

Mismatch:
0a1,3
> fname => ../data/prpr5.bean
> 
> what is in side =>
6c9
<     p(x, x);
---
>     p(xx);
9c12
<             p(x, x);
---
>             p(xx);
11c14
<                 p(x, x);
---
>                 p(xx);
13c16
<                 p(x, x);
---
>                 p(xx);
17c20
<                 p(x, x);
---
>                 p(xx);
20,21c23
<                     p(x, x);
<                     p(x, x);
---
>                     p(xx);p(xx);
23c25
<                 p(x, x);
---
>                 p(xx);
25c27
<             p(x, x);
---
>             p(xx);
29,30c31
<             p(x, x);
<             p(x, x);
---
>             p(xx);p(xx);
33c34
<             p(x, x);
---
>             p(xx);
35c36
<             p(x, x);
---
>             p(xx);
43a45
> 

******************************************   Parsing prpr6.bean:

Syntax error
Mismatch:
1,41c1
< 
< proc main()
< 
<     p(4);
< end
< 
< proc p()
<     int m;
<     int n;
<     int diff;
< 
<     read m;
<     read n;
<     while m != n do
<         diff := 0;
<         while m * n > 0 do
<             m := m - 1;
<             n := n - 1;
<             diff := diff + 1;
<         od
<         if m != 0 then
<             n := diff;
<         else
<             m := diff;
<         fi
<     od
<     write m;
< end
< 
< proc q()
<     bool x;
< 
<     x := true and true or true and false;
< end
< 
< proc r()
<     int x;
< 
<     x := 6;
<     s(x, x);
< end
---
> fname => ../data/prpr6.bean

******************************************   Parsing bell.bean:

Mismatch:
0a1,3
> fname => ../data/bell.bean
> 
> what is in side =>
6c9
<     write "Type integer n: ";
---
>     write "Type integer n: " ;
9c12
<     write "Bell(n) is: ";
---
>     write "Bell(n) is: " ;
11c14
<     write "\n";
---
>     write "\n" ;
29a33
> 

******************************************   Parsing fib.bean:

Mismatch:
0a1,3
> fname => ../data/fib.bean
> 
> what is in side =>
6c9
<     write ">";
---
>     write ">" ;
10c13
<     write "\n";
---
>     write "\n" ;
24a28
> 

******************************************   Parsing gcd.bean:

Illegal Character on line 28, col 18.
Mismatch:
1,33c1
< 
< proc main()
<     int x;
<     int y;
<     int temp;
<     int quotient;
<     int remainder;
< 
<     write "Input two positive integers: ";
<     read x;
<     read y;
<     write "\n";
<     if x < y then
<         temp := x;
<         x := y;
<         y := temp;
<     fi
<     write "The gcd of ";
<     write x;
<     write " and ";
<     write y;
<     write " is ";
<     quotient := x / y;
<     remainder := x - quotient * y;
<     while remainder > 0 do
<         x := y;
<         y := remainder;
<         quotient := x / y;
<         remainder := x - quotient * y;
<     od
<     write y;
<     write "\n";
< end
---
> fname => ../data/gcd.bean

******************************************   Parsing hail.bean:

Illegal Character on line 23, col 14.
Mismatch:
1,30c1
< 
< proc main()
<     int n;
<     int result;
< 
<     n := 1;
<     while n < 21 do
<         hail(n, result);
<         write result;
<         write " ";
<         n := n + 1;
<     od
<     write "\n";
< end
< 
< proc hail(val int in, ref int out)
<     int count;
< 
<     count := 1;
<     if in = 1 then
<         out := count;
<     else
<         if in / 2 * 2 = in then
<             hail(in / 2, count);
<         else
<             hail(3 * in + 1, count);
<         fi
<         out := count + 1;
<     fi
< end
---
> fname => ../data/hail.bean

******************************************   Parsing power.bean:

Illegal Character on line 21, col 16.
Mismatch:
1,30c1
< 
< proc main()
<     float x;
<     float result;
<     int n;
< 
<     write "Float x: ";
<     read x;
<     write "Positive integer n: ";
<     read n;
<     power(x, n, result);
<     write "x^n is: ";
<     write result;
<     write "\n";
< end
< 
< proc power(val float x, val int n, ref float out)
<     float res;
< 
<     if n = 1 then
<         out := x;
<     else
<         power(x * x, n / 2, res);
<         if 2 * (n / 2) = n then
<             out := res;
<         else
<             out := x * res;
<         fi
<     fi
< end
---
> fname => ../data/power.bean

******************************************   Parsing stddev.bean:

Syntax error
Mismatch:
1,27c1
< 
< proc main()
<     int x;
<     int sum;
<     int sumsq;
<     int mean;
<     int count;
<     int done;
< 
<     write "Type a list of integers, ending with a negative number\n";
<     read x;
<     done := x < 0;
<     while not done do
<         count := count + 1;
<         sum := sum + x;
<         sumsq := sumsq + x * x;
<         read x;
<         done := x < 0;
<     od
<     mean := sum / count;
<     write "The mean is ";
<     write mean;
<     write "\n";
<     write "The variance is ";
<     write sumsq / count - mean * mean;
<     write "\n";
< end
---
> fname => ../data/stddev.bean

******************************************   Parsing strange.bean:

Mismatch:
0a1,3
> fname => ../data/strange.bean
> 
> what is in side =>
9,10c12,13
<     z.fA := 42;
<     z.fB := {fB = true, gA = false};
---
>     fA.z := 42;
>     fB.z := {fB = true, gA = false};
38a42
> 

******************************************   Parsing lex11.bad.bean:
proc main()
int x;
  x := @ ;
end
Result:
fname => ../data/lex11.bad.bean 
Illegal Character on line 3, col 7.

******************************************   Parsing lex12.bad.bean:
proc main()
int x;
int xyz_ab$;
bool z;
    x := 3;
    z := true;
    write z;
end
Result:
fname => ../data/lex12.bad.bean 
Illegal Character on line 3, col 10.

******************************************   Parsing lex13.bad.bean:
proc main()
    int int; int := 0;
end
Result:
fname => ../data/lex13.bad.bean 
Syntax error

******************************************   Parsing syn12.bad.bean:
proc main ()
    bool test; 
end

proc fib(int val n, ref int ref out)
    int f1;
    int f2;

    out := n;
}

Result:
fname => ../data/syn12.bad.bean 
Syntax error

******************************************   Parsing syn13.bad.bean:
proc main()
int x;
int y;
# Sequence of statements cannot be empty
end

Result:
fname => ../data/syn13.bad.bean 
Syntax error

******************************************   Parsing syn14.bad.bean:
proc main()
int m;
int n;
    read n;
    while n>1 do
        m := ( n;
        while m := m do
            if then
                n := n - 1;
                m := m - 1
                if true then m := m - 1; else n := 6*n + 4;
                fi
             fi
        od
    od
end
Result:
fname => ../data/syn14.bad.bean 
Syntax error

******************************************   Parsing syn15.bad.bean:
proc main()
    int x; x := 0; x := 1
end
Result:
fname => ../data/syn15.bad.bean 
Syntax error

******************************************   Parsing syn16.bad.bean:
proc main()
typedef {b: int} t

t a;
    t.b := 0;
end
Result:
fname => ../data/syn16.bad.bean 
Syntax error

******************************************   Parsing syn17.bad.bean:
proc main()
int n;
    n := 0;
end
    n := 1;
Result:
fname => ../data/syn17.bad.bean 
Syntax error

******************************************   Parsing syn18.bad.bean:
proc main()
int m;
int n;
    read m;
    write if m=n then
end
Result:
fname => ../data/syn18.bad.bean 
Syntax error

******************************************   Parsing syn19.bad.bean:
proc main(val int a, ref)
int m; read m;
end
Result:
fname => ../data/syn19.bad.bean 
Syntax error


--- End of testing for bingfengl ---\n

============================================
src/bean_ast.ml
02:03:11_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty


type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)




type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref


type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program

(*
let printBeantype beanTypeData = match beanTypeData with
| Bool -> Printf.printf " Bool "
| Int -> Printf.printf " Int "
| IdentType(s) ->  Printf.printf " string => %s" s

let rec printTypedefStruct typedefStructData = match typedefStructData with
| SingleTypeTerm(id , tp) -> (Printf.printf "id => %s , type => \n" id ; printBeantype tp)
| ListTypeTerm(id , tps) -> (Printf.printf "Listype name => %s " id;List.iter (printTypedefStruct) tps)

let rec printTypedefs typedefData = match typedefData with
| [] -> Printf.printf "Empty \n "
| (hstructList,hid)::t -> ( Printf.printf "typedef name => %s : \n  " hid; List.iter (printTypedefStruct) hstructList ; printTypedefs t )

*)

(* Print typedef *)

let printBeanType fmt (btype,suffix) =  match btype with
| Bool -> Format.fprintf fmt "bool%s" suffix 
| Int ->  Format.fprintf fmt "int%s" suffix  
| IdentType(ident) -> Format.fprintf fmt "%s%s" ident suffix

(* mode = 1 ==> in typedef *)
let rec printTypedefStruct fmt (arrangeMode,typedefStructData) = match typedefStructData with
| SingleTypeTerm (btype) -> if arrangeMode = 1 then printBeanType fmt (btype,"") else printBeanType fmt (btype," ")
| SingleTypeTermWithIdent (ident,nestTypedefStructData) ->
  if arrangeMode = 1 then Format.fprintf fmt "%s : %a" ident printTypedefStruct (arrangeMode,nestTypedefStructData)
  else Format.fprintf fmt "%a%s" printTypedefStruct (arrangeMode,nestTypedefStructData) ident
| ListTypeTerm (listTypedefStructData) ->(Format.fprintf fmt "{"  ;
  List.iter (fun x -> if x = List.nth listTypedefStructData ((List.length listTypedefStructData)-1) 
    then printTypedefStruct fmt (arrangeMode,x)
    else (printTypedefStruct fmt (arrangeMode,x) ; Format.fprintf fmt ", ")) listTypedefStructData;
  Format.fprintf fmt "}" )
| TypedefEnd -> Format.fprintf fmt "end with type def \n"

let printSingleTypedef fmt singleTypedefData = let arrangeMode = 1 in match singleTypedefData with
| (typedefStruct,ident) -> Format.fprintf fmt "typedef %a %s\n" printTypedefStruct (arrangeMode,typedefStruct) ident 
 

let printTypedefList fmt typedefDataList = (Format.fprintf fmt "@[";
  List.iter (printSingleTypedef fmt) typedefDataList;
  Format.fprintf fmt "@]@.")




(* Print method delc*)


let printFuncIndicator fmt funcIndicator = match funcIndicator with
| Val -> Format.fprintf fmt "val "
| Ref -> Format.fprintf fmt "ref "

let printFuncparams fmt singleFuncparamData =  let arrangeMode = 1 in match singleFuncparamData with
| (funcIndicator,typedefStruct,ident) -> Format.fprintf fmt  "%a%a %s"  printFuncIndicator funcIndicator printTypedefStruct (arrangeMode,typedefStruct) ident

let printFuncheader fmt funcheaderData = match funcheaderData with
| (funcname,funcparams) -> (Format.fprintf fmt "%s(" funcname ;
List.iter (fun x -> if x = List.nth funcparams ((List.length funcparams)-1) 
    then printFuncparams fmt x
    else (printFuncparams fmt x ; Format.fprintf fmt ", ")) funcparams;
    Format.fprintf fmt ")")


let printFuncVardef fmt funcVardefData = let arrangeMode = 2 in List.iter (fun x -> 
   if x = List.nth funcVardefData ((List.length funcVardefData)-1)
   then (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";")
   else (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";@ "))
  funcVardefData


(*//TODO *)
let rec printLvalue fmt singleLvalue = match singleLvalue with
| LId(ident) -> Format.fprintf fmt "%s" ident
| LField(recLvalue,ident) -> (Format.fprintf fmt "%s." ident; printLvalue fmt recLvalue)
| LvalueNone -> Format.fprintf fmt "Empty lvalue"

let printBinop fmt singleBinop = match singleBinop with
| Op_add -> Format.fprintf fmt  " + "
| Op_sub -> Format.fprintf fmt  " - "
| Op_mul -> Format.fprintf fmt  " * "
| Op_div -> Format.fprintf fmt " / " 
| Op_eq -> Format.fprintf fmt  " = "
| Op_lt -> Format.fprintf fmt  " < "
| Op_gt -> Format.fprintf fmt  " > "
| Op_neq -> Format.fprintf fmt  " != "
| Op_lte -> Format.fprintf fmt  " <= "
| Op_gte -> Format.fprintf fmt  " >= "
| Op_and -> Format.fprintf fmt  " and "
| Op_or -> Format.fprintf fmt  " or "

let printUnop fmt singleUnop = match singleUnop with
| Op_minus -> Format.fprintf fmt "-"
| Op_not -> Format.fprintf fmt "!"

let rec printExpr fmt singleExpr = match singleExpr with
| Ebool(bool_val) -> Format.fprintf fmt "%B" bool_val
| Eint(int_val) -> Format.fprintf fmt "%d" int_val
| Elval(lvalue) -> printLvalue fmt lvalue
| Ebinop(expr_one,binop,expr_two) -> (printExpr fmt expr_one;
  printBinop fmt binop; printExpr fmt expr_two)
| Eunop(unop,expr) -> (printUnop fmt unop ; printExpr fmt expr)
| Eident(ident) -> Format.fprintf fmt "%s " ident
| Ebracket(expr) -> (Format.fprintf fmt "( " ; printExpr fmt expr  ;Format.fprintf fmt " ) ")


let rec printRvalue fmt singleRvalue = match singleRvalue with
| Rexpr(expr) -> printExpr fmt expr
| RField(rvalue,expr) -> (printRvalue fmt rvalue;
  printExpr fmt expr)
| Rassign(str,rvalue) -> (Format.fprintf fmt "%s = " str;
  printRvalue fmt rvalue)
| Rstmts(rvalueList) -> (Format.fprintf fmt "{";
  List.iter (fun x ->( if x = List.nth rvalueList ((List.length rvalueList)-1) 
  then printRvalue fmt x
  else (printRvalue fmt x ;Format.fprintf fmt ", ") )) rvalueList;
  Format.fprintf fmt "}")
| Rempty -> Format.fprintf fmt "Empty Rvalue "

let getIdent identNum = String.make identNum ' '

let printEndStmt fmt isLast lastStr = match isLast with
  | true -> Format.fprintf fmt  "%s" lastStr
  | false -> Format.fprintf fmt  "%s@ " lastStr

let rec printStmt fmt (initIdent,isLast,singleStmt) = match singleStmt with

| Assign(lvalue, rvalue) -> (printLvalue fmt lvalue;
  Format.fprintf fmt  " := ";
  printRvalue fmt rvalue;
  printEndStmt fmt isLast ";")

| AssignRvalueList(lvalue,rvalueList) ->(printLvalue fmt lvalue;
  Format.fprintf fmt  "={";
  List.iter (printRvalue fmt) rvalueList;
  Format.fprintf fmt "}";
  printEndStmt fmt isLast ";")

| Read(lvalue) -> (Format.fprintf fmt  "read ";
  printLvalue fmt lvalue;
  printEndStmt fmt isLast ";")

| Write(expr) -> (Format.fprintf fmt  "write ";
  printExpr fmt expr;
  printEndStmt fmt isLast ";")

| StmtNone -> Format.fprintf fmt "StmtNone"

| Method(methodname, paramList) -> (Format.fprintf fmt "%s(" methodname ;
  List.iter (fun x -> if x = List.nth paramList ((List.length paramList)-1) 
  then printExpr fmt x
  else (printExpr fmt x; Format.fprintf fmt ", " )) paramList;
  Format.fprintf fmt ")";
  printEndStmt fmt isLast ";")

| VarDec(beantype, ident) -> (printBeanType fmt (beantype,"");
  Format.fprintf fmt "%s " ident;
  printEndStmt fmt isLast ";")

| WhileDec(expr, stmtList) ->(Format.fprintf fmt "while %a do @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth stmtList ((List.length stmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) stmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt"@ od";
  printEndStmt fmt isLast "")

| IfDec(expr, thenStmtList, elseStmtList) -> (Format.fprintf fmt "if %a then @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth thenStmtList ((List.length thenStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) thenStmtList;
  Format.fprintf fmt " @]";
  if (List.length elseStmtList) != 0 then (Format.fprintf fmt " @ ";Format.fprintf fmt "else @ ");
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth elseStmtList ((List.length elseStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) elseStmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt  "@ fi";
  printEndStmt fmt isLast "")

let printFuncBody fmt funcBodyData = let initIdentFactor = 4 in List.iter (fun x -> if x = List.nth funcBodyData ((List.length funcBodyData)-1) 
    then printStmt fmt (initIdentFactor,true,x)
    else printStmt fmt (initIdentFactor,false,x)) funcBodyData
(*
let printSingleFuncdef fmt initIdent initIdentFactor singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) -> Format.fprintf fmt "@[proc %a @ %a @ @ %a end@]@." printFuncheader (initIdent,initIdentFactor,funcheader) printFuncVardef (initIdent,initIdentFactor,funcvardef)  printFuncBody (initIdent,initIdentFactor,funcbody)
*)
let printSingleFuncdef fmt singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) ->(Format.fprintf fmt "proc %a" printFuncheader funcheader;
  if (List.length funcvardef) !=0 then Format.fprintf fmt " @ %a " printFuncVardef funcvardef;
  if (List.length funcbody) != 0 then Format.fprintf fmt " @ @ %a " printFuncBody funcbody;
  Format.fprintf fmt "\nend\n\n")

let printFuncdefList fmt funcdefDataList = let iniIdent = 4 in (Format.fprintf fmt "@[<v %d>" iniIdent ; List.iter (printSingleFuncdef fmt) funcdefDataList ;Format.fprintf fmt "@] " )









============================================
src/Makefile.depend
02:03:11_Monday_11_April_2016
============================================
bean.cmo :
bean.cmx :
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi :
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_pprint.cmi
bean_pprint.cmx : bean_pprint.cmi
bean.cmo :
bean.cmx :
============================================
src/bean.ml
02:03:11_Monday_11_April_2016
============================================
open Bean_lex
module P = Bean_parse

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  try
      (* Open the input file *)
      let infile = match !infile_name with
      | None -> stdin
      | Some fname -> begin Printf.printf "fname => %s \n" fname;open_in fname end in
      (* Initialize lexing buffer *)
      let lexbuf = Lexing.from_channel infile in
      (* Call the parser *)
      let prog = Bean_parse.start_state Bean_lex.token lexbuf in
      match !mode with
      | PrettyPrint ->
        Bean_pprint.print_program Format.std_formatter prog 
      | Compile -> Printf.eprintf "Sorry, cannot compile yet."
  with
      | Parsing.Parse_error -> Printf.eprintf "Syntax error\n"
      | LexFail lexbuf -> let position = Lexing.lexeme_start_p lexbuf in
          Printf.eprintf "Illegal Character on line %d, col %d.\n" position.Lexing.pos_lnum
          (position.Lexing.pos_cnum - position.Lexing.pos_bol)

let _ = main ()
============================================
src/bean_pprint.ml
02:03:11_Monday_11_April_2016
============================================
open Bean_ast
open Format

let print_program fmt prog = (Printf.printf " \nwhat is in side => \n" ;
	Format.set_max_indent 100;
	printTypedefList fmt prog.typedefs;
	printFuncdefList fmt prog.funcdefs
)
============================================
src/bean_lex.mll
02:03:11_Monday_11_April_2016
============================================
{
open Bean_parse
let line_num = ref 0

exception LexFail of Lexing.lexbuf


let lex_fail lexbuf = raise (LexFail lexbuf)
}

let apostro = '''
let digit = ['0' - '9']
let alpha = ['a' - 'z' 'A' - 'Z']
let alnum = alpha | digit (* unused *)
let digits = digit+ (* unused *)
let underscore = '_'
let ident = (alpha|underscore)(alpha|underscore|apostro)* (* to be changed to (alpha|underscore)(alpha|underscore|apostro)* *)
let typedef_value_init = (ident ':' ident) (* unused *)
let function_value_init = ident ident (* unused *)

let comment = '#'[^'\n']*'\n'

rule token = parse
    [' ' '\t']    { token lexbuf }     (* skip blanks *)
  | '\n'          { incr line_num; Lexing.new_line lexbuf ; token lexbuf }
  (*| '-'?['0'-'9']+ as lxm { IPrintf.printf "meet typedef \n" ;flush stdout;NT_CONST(int_of_string lxm) }*)
  | '-'?['0'-'9']+ as lxm{INT_VAL(int_of_string(lxm)) }
  (* keywords *)
  | comment {incr line_num;token lexbuf }
  | ':' { flush stdout;COLON }
  | '{' { LEFT_BRACE }
  | '}' { RIGHT_BRACE }
  | "typedef" {TYPEDEF("typedef") }
  | "proc" {PROC}
  (*| typedef_value_init  as temp{ Printf.printf "meet typedef_value_init => %s \n" temp;flush stdout;TYPEDEF_VALUE_INIT }*)
  | ',' { COMMA }
  | '.' { DOT }
  | "end" { END }
  | "val" { VAL }
  | "ref" {REF }
  | '(' { LEFT_PAREN }
  | ')' { RIGHT_PAREN }
  | "while" {WHILE }
  | "do" { DO }
  | "od" { OD }
  | "if" { IF }
  | "then" {THEN }
  | "else" {ELSE }
  | "fi" {FI} 
  | "bool" {BOOL }
  | "int" { INT }
  (*| "true" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL true }*)
  | "true" {BOOL_VAL true}
  (*| "false" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL false }*)
  | "false" {BOOL_VAL false}
  | "read" { READ }
  | "write" { WRITE }
  (*| ":=" { Printf.printf "meet typedef \n" ;flush stdout;ASSIGN }*)
  | ":=" {EQ_COL}
  (*| '(' { LPAREN }*)
  (*| ')' { RPAREN }*)
  | "!=" {NEQ }
  | "<="{ LTE }
  | ">="{ GTE }
  | '=' { EQ }
  | '<' { LT }
  | '+' { PLUS }
  | '-' { MINUS }
  | '*' { MUL }
  | ';' { SEMICOLON }
  | '>' { GT}
  | '"' [^ '"' '\t' '\n' '\r' ]* '"' as lxm{STRING_VAL(lxm)}
  (*| ident as lxm { IDENT lxm }*)
  | ident as lxm{  lxm ;flush stdout;IDENTIFIER(lxm) }
  | eof { flush stdout;EOF }
  | _   { lex_fail lexbuf }
============================================
src/bean_ast.mli
02:03:11_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty

type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)


type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref



type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program
(*
val printBeantype : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit 
val printTypedefs : (typedefStruct list * ident) list -> unit
*)
(*
val printBeanType : beantype -> unit 
val printSingleTypeDef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit 
*)
(*
val printBeanType : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit
val printSingleTypedef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit
*)
(*
val printFuncIndicator : valRef -> unit
val printFuncparams : valRef * typedefStruct * ident -> unit
val printFuncheader : ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : typedefStruct list -> unit
val printLvalue : lvalue -> unit
val printBinop : binop -> unit
val printUnop : unop -> unit
val printExpr : expr -> unit
val printRvalue : rvalue -> unit
val printStmt : stmt -> unit
val printFuncBody : stmt list -> unit
val printSingleFuncdef : (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit 
val printFuncdefList : ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit*)
val printBeanType : Format.formatter -> beantype * string -> unit
val printTypedefStruct : Format.formatter -> int * typedefStruct -> unit
val printSingleTypedef : Format.formatter -> typedefStruct * ident -> unit
val printTypedefList : Format.formatter -> (typedefStruct * ident) list -> unit
val printFuncIndicator : Format.formatter -> valRef -> unit
val printFuncparams : Format.formatter -> valRef * typedefStruct * ident -> unit
val printFuncheader : Format.formatter -> ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : Format.formatter -> typedefStruct list -> unit
val printLvalue : Format.formatter -> lvalue -> unit
val printBinop : Format.formatter -> binop -> unit
val printUnop : Format.formatter -> unop -> unit
val printExpr : Format.formatter -> expr -> unit
val printRvalue : Format.formatter -> rvalue -> unit
val getIdent : int -> ident
val printEndStmt : Format.formatter -> bool -> ident -> unit
val printStmt : Format.formatter -> int * bool * stmt -> unit
val printFuncBody : Format.formatter -> stmt list -> unit
val printSingleFuncdef : Format.formatter -> (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit
val printFuncdefList : Format.formatter -> ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit============================================
src/feedback.txt
02:03:11_Monday_11_April_2016
============================================
============================================
vis/bingfengl.out
02:01:59_Monday_11_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  bingfengl

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc bean_parse.mly
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
90 states, 5239 transitions, table size 21496 bytes
ocamlopt  -g -c bean_lex.ml
File "bean_lex.mll", line 34, characters 11-16:
Error: Unbound constructor ROC
make: *** [bean_lex.cmx] Error 2

make failed (exited with status 2)

--- End of testing for bingfengl ---\n

============================================
src/bean_ast.mli
02:01:57_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty

type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)


type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref



type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program
(*
val printBeantype : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit 
val printTypedefs : (typedefStruct list * ident) list -> unit
*)
(*
val printBeanType : beantype -> unit 
val printSingleTypeDef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit 
*)
(*
val printBeanType : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit
val printSingleTypedef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit
*)
(*
val printFuncIndicator : valRef -> unit
val printFuncparams : valRef * typedefStruct * ident -> unit
val printFuncheader : ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : typedefStruct list -> unit
val printLvalue : lvalue -> unit
val printBinop : binop -> unit
val printUnop : unop -> unit
val printExpr : expr -> unit
val printRvalue : rvalue -> unit
val printStmt : stmt -> unit
val printFuncBody : stmt list -> unit
val printSingleFuncdef : (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit 
val printFuncdefList : ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit*)
val printBeanType : Format.formatter -> beantype * string -> unit
val printTypedefStruct : Format.formatter -> int * typedefStruct -> unit
val printSingleTypedef : Format.formatter -> typedefStruct * ident -> unit
val printTypedefList : Format.formatter -> (typedefStruct * ident) list -> unit
val printFuncIndicator : Format.formatter -> valRef -> unit
val printFuncparams : Format.formatter -> valRef * typedefStruct * ident -> unit
val printFuncheader : Format.formatter -> ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : Format.formatter -> typedefStruct list -> unit
val printLvalue : Format.formatter -> lvalue -> unit
val printBinop : Format.formatter -> binop -> unit
val printUnop : Format.formatter -> unop -> unit
val printExpr : Format.formatter -> expr -> unit
val printRvalue : Format.formatter -> rvalue -> unit
val getIdent : int -> ident
val printEndStmt : Format.formatter -> bool -> ident -> unit
val printStmt : Format.formatter -> int * bool * stmt -> unit
val printFuncBody : Format.formatter -> stmt list -> unit
val printSingleFuncdef : Format.formatter -> (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit
val printFuncdefList : Format.formatter -> ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit============================================
src/bean_ast.ml
02:01:57_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty


type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)




type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref


type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program

(*
let printBeantype beanTypeData = match beanTypeData with
| Bool -> Printf.printf " Bool "
| Int -> Printf.printf " Int "
| IdentType(s) ->  Printf.printf " string => %s" s

let rec printTypedefStruct typedefStructData = match typedefStructData with
| SingleTypeTerm(id , tp) -> (Printf.printf "id => %s , type => \n" id ; printBeantype tp)
| ListTypeTerm(id , tps) -> (Printf.printf "Listype name => %s " id;List.iter (printTypedefStruct) tps)

let rec printTypedefs typedefData = match typedefData with
| [] -> Printf.printf "Empty \n "
| (hstructList,hid)::t -> ( Printf.printf "typedef name => %s : \n  " hid; List.iter (printTypedefStruct) hstructList ; printTypedefs t )

*)

(* Print typedef *)

let printBeanType fmt (btype,suffix) =  match btype with
| Bool -> Format.fprintf fmt "bool%s" suffix 
| Int ->  Format.fprintf fmt "int%s" suffix  
| IdentType(ident) -> Format.fprintf fmt "%s%s" ident suffix

(* mode = 1 ==> in typedef *)
let rec printTypedefStruct fmt (arrangeMode,typedefStructData) = match typedefStructData with
| SingleTypeTerm (btype) -> if arrangeMode = 1 then printBeanType fmt (btype,"") else printBeanType fmt (btype," ")
| SingleTypeTermWithIdent (ident,nestTypedefStructData) ->
  if arrangeMode = 1 then Format.fprintf fmt "%s : %a" ident printTypedefStruct (arrangeMode,nestTypedefStructData)
  else Format.fprintf fmt "%a%s" printTypedefStruct (arrangeMode,nestTypedefStructData) ident
| ListTypeTerm (listTypedefStructData) ->(Format.fprintf fmt "{"  ;
  List.iter (fun x -> if x = List.nth listTypedefStructData ((List.length listTypedefStructData)-1) 
    then printTypedefStruct fmt (arrangeMode,x)
    else (printTypedefStruct fmt (arrangeMode,x) ; Format.fprintf fmt ", ")) listTypedefStructData;
  Format.fprintf fmt "}" )
| TypedefEnd -> Format.fprintf fmt "end with type def \n"

let printSingleTypedef fmt singleTypedefData = let arrangeMode = 1 in match singleTypedefData with
| (typedefStruct,ident) -> Format.fprintf fmt "typedef %a %s\n" printTypedefStruct (arrangeMode,typedefStruct) ident 
 

let printTypedefList fmt typedefDataList = (Format.fprintf fmt "@[";
  List.iter (printSingleTypedef fmt) typedefDataList;
  Format.fprintf fmt "@]@.")




(* Print method delc*)


let printFuncIndicator fmt funcIndicator = match funcIndicator with
| Val -> Format.fprintf fmt "val "
| Ref -> Format.fprintf fmt "ref "

let printFuncparams fmt singleFuncparamData =  let arrangeMode = 1 in match singleFuncparamData with
| (funcIndicator,typedefStruct,ident) -> Format.fprintf fmt  "%a%a %s"  printFuncIndicator funcIndicator printTypedefStruct (arrangeMode,typedefStruct) ident

let printFuncheader fmt funcheaderData = match funcheaderData with
| (funcname,funcparams) -> (Format.fprintf fmt "%s(" funcname ;
List.iter (fun x -> if x = List.nth funcparams ((List.length funcparams)-1) 
    then printFuncparams fmt x
    else (printFuncparams fmt x ; Format.fprintf fmt ", ")) funcparams;
    Format.fprintf fmt ")")


let printFuncVardef fmt funcVardefData = let arrangeMode = 2 in List.iter (fun x -> 
   if x = List.nth funcVardefData ((List.length funcVardefData)-1)
   then (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";")
   else (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";@ "))
  funcVardefData


(*//TODO *)
let rec printLvalue fmt singleLvalue = match singleLvalue with
| LId(ident) -> Format.fprintf fmt "%s" ident
| LField(recLvalue,ident) -> (Format.fprintf fmt "%s." ident; printLvalue fmt recLvalue)
| LvalueNone -> Format.fprintf fmt "Empty lvalue"

let printBinop fmt singleBinop = match singleBinop with
| Op_add -> Format.fprintf fmt  " + "
| Op_sub -> Format.fprintf fmt  " - "
| Op_mul -> Format.fprintf fmt  " * "
| Op_div -> Format.fprintf fmt " / " 
| Op_eq -> Format.fprintf fmt  " = "
| Op_lt -> Format.fprintf fmt  " < "
| Op_gt -> Format.fprintf fmt  " > "
| Op_neq -> Format.fprintf fmt  " != "
| Op_lte -> Format.fprintf fmt  " <= "
| Op_gte -> Format.fprintf fmt  " >= "
| Op_and -> Format.fprintf fmt  " and "
| Op_or -> Format.fprintf fmt  " or "

let printUnop fmt singleUnop = match singleUnop with
| Op_minus -> Format.fprintf fmt "-"
| Op_not -> Format.fprintf fmt "!"

let rec printExpr fmt singleExpr = match singleExpr with
| Ebool(bool_val) -> Format.fprintf fmt "%B" bool_val
| Eint(int_val) -> Format.fprintf fmt "%d" int_val
| Elval(lvalue) -> printLvalue fmt lvalue
| Ebinop(expr_one,binop,expr_two) -> (printExpr fmt expr_one;
  printBinop fmt binop; printExpr fmt expr_two)
| Eunop(unop,expr) -> (printUnop fmt unop ; printExpr fmt expr)
| Eident(ident) -> Format.fprintf fmt "%s " ident
| Ebracket(expr) -> (Format.fprintf fmt "( " ; printExpr fmt expr  ;Format.fprintf fmt " ) ")


let rec printRvalue fmt singleRvalue = match singleRvalue with
| Rexpr(expr) -> printExpr fmt expr
| RField(rvalue,expr) -> (printRvalue fmt rvalue;
  printExpr fmt expr)
| Rassign(str,rvalue) -> (Format.fprintf fmt "%s = " str;
  printRvalue fmt rvalue)
| Rstmts(rvalueList) -> (Format.fprintf fmt "{";
  List.iter (fun x ->( if x = List.nth rvalueList ((List.length rvalueList)-1) 
  then printRvalue fmt x
  else (printRvalue fmt x ;Format.fprintf fmt ", ") )) rvalueList;
  Format.fprintf fmt "}")
| Rempty -> Format.fprintf fmt "Empty Rvalue "

let getIdent identNum = String.make identNum ' '

let printEndStmt fmt isLast lastStr = match isLast with
  | true -> Format.fprintf fmt  "%s" lastStr
  | false -> Format.fprintf fmt  "%s@ " lastStr

let rec printStmt fmt (initIdent,isLast,singleStmt) = match singleStmt with

| Assign(lvalue, rvalue) -> (printLvalue fmt lvalue;
  Format.fprintf fmt  " := ";
  printRvalue fmt rvalue;
  printEndStmt fmt isLast ";")

| AssignRvalueList(lvalue,rvalueList) ->(printLvalue fmt lvalue;
  Format.fprintf fmt  "={";
  List.iter (printRvalue fmt) rvalueList;
  Format.fprintf fmt "}";
  printEndStmt fmt isLast ";")

| Read(lvalue) -> (Format.fprintf fmt  "read ";
  printLvalue fmt lvalue;
  printEndStmt fmt isLast ";")

| Write(expr) -> (Format.fprintf fmt  "write ";
  printExpr fmt expr;
  printEndStmt fmt isLast ";")

| StmtNone -> Format.fprintf fmt "StmtNone"

| Method(methodname, paramList) -> (Format.fprintf fmt "%s(" methodname ;
  List.iter (fun x -> if x = List.nth paramList ((List.length paramList)-1) 
  then printExpr fmt x
  else (printExpr fmt x; Format.fprintf fmt ", " )) paramList;
  Format.fprintf fmt ")";
  printEndStmt fmt isLast ";")

| VarDec(beantype, ident) -> (printBeanType fmt (beantype,"");
  Format.fprintf fmt "%s " ident;
  printEndStmt fmt isLast ";")

| WhileDec(expr, stmtList) ->(Format.fprintf fmt "while %a do @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth stmtList ((List.length stmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) stmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt"@ od";
  printEndStmt fmt isLast "")

| IfDec(expr, thenStmtList, elseStmtList) -> (Format.fprintf fmt "if %a then @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth thenStmtList ((List.length thenStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) thenStmtList;
  Format.fprintf fmt " @]";
  if (List.length elseStmtList) != 0 then (Format.fprintf fmt " @ ";Format.fprintf fmt "else @ ");
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth elseStmtList ((List.length elseStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) elseStmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt  "@ fi";
  printEndStmt fmt isLast "")

let printFuncBody fmt funcBodyData = let initIdentFactor = 4 in List.iter (fun x -> if x = List.nth funcBodyData ((List.length funcBodyData)-1) 
    then printStmt fmt (initIdentFactor,true,x)
    else printStmt fmt (initIdentFactor,false,x)) funcBodyData
(*
let printSingleFuncdef fmt initIdent initIdentFactor singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) -> Format.fprintf fmt "@[proc %a @ %a @ @ %a end@]@." printFuncheader (initIdent,initIdentFactor,funcheader) printFuncVardef (initIdent,initIdentFactor,funcvardef)  printFuncBody (initIdent,initIdentFactor,funcbody)
*)
let printSingleFuncdef fmt singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) ->(Format.fprintf fmt "proc %a" printFuncheader funcheader;
  if (List.length funcvardef) !=0 then Format.fprintf fmt " @ %a " printFuncVardef funcvardef;
  if (List.length funcbody) != 0 then Format.fprintf fmt " @ @ %a " printFuncBody funcbody;
  Format.fprintf fmt "\nend\n\n")

let printFuncdefList fmt funcdefDataList = let iniIdent = 4 in (Format.fprintf fmt "@[<v %d>" iniIdent ; List.iter (printSingleFuncdef fmt) funcdefDataList ;Format.fprintf fmt "@] " )









============================================
src/bean_pprint.ml
02:01:58_Monday_11_April_2016
============================================
open Bean_ast
open Format

let print_program fmt prog = (Printf.printf " \nwhat is in side => \n" ;
	Format.set_max_indent 100;
	printTypedefList fmt prog.typedefs;
	printFuncdefList fmt prog.funcdefs
)
============================================
src/Makefile.depend
02:01:58_Monday_11_April_2016
============================================
bean.cmo :
bean.cmx :
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi :
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_pprint.cmi
bean_pprint.cmx : bean_pprint.cmi
bean.cmo :
bean.cmx :
============================================
src/bean_pprint.mli
02:01:58_Monday_11_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/bean_parse.mly
02:01:57_Monday_11_April_2016
============================================
/* ocamlyacc parser for bean */
%{
open Bean_ast
%}

%token <bool> BOOL_VAL
%token <int> INT_VAL
%token <string> STRING_VAL
%token WRITE READ
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token PLUS MINUS MUL DIV
%token UMINUS
%token COLON
%token SEMICOLON
%token AND OR NOT
%token EOF


%token <string> IDENTIFIER
%token LEFT_PAREN RIGHT_PAREN
%token <string> TYPEDEF
%token TYPEDEF_VALUE_INIT
%token DOT
%token COMMA
%token END
%token VAL
%token REF
%token LEFT_BRACE RIGHT_BRACE
%token WHILE DO OD
%token IF THEN ELSE FI
%token BOOL INT
%token PROC
%token EQ_COL
%left OR
%left AND
%nonassoc EQ NEQ LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right EQ_COL
%nonassoc NOT UMINUS

%type <Bean_ast.program> start_state

%start start_state
%%


/*
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
*/

start_state:
| type_definition procedure_definition {{typedefs = List.rev $1;funcdefs = List.rev $2}}

/*typdef ? identifier*/
type_definition:
| type_definition TYPEDEF type_spec IDENTIFIER {($3,$4)::$1}
| {[]}

type_spec:
| primitive_type {$1}
| IDENTIFIER {SingleTypeTerm((IdentType $1))}
/*typdef {?} identifier*/
| LEFT_BRACE field_definition RIGHT_BRACE {ListTypeTerm( List.rev $2)}

primitive_type:
| BOOL {SingleTypeTerm(Bool)}
| INT {SingleTypeTerm(Int)}

field_definition:
| rec_field_definition IDENTIFIER COLON type_spec {SingleTypeTermWithIdent($2,$4)::$1}

rec_field_definition:
| field_definition COMMA {$1}
| {[]}








/* At least one procedure required */
/* (functionDeclaration * typedefStruct  * stmt list) list */
procedure_definition:
| rec_procedure_definition PROC procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}

/* (functionDeclaration * typedefStruct  * stmt list) list */
rec_procedure_definition:
| procedure_definition {$1}
| {[]}

/*type functionDeclaration = (string*funcDecParamList)*/
/*type funcDecParamList = (valRef*typedefStruct*string) list*/
procedure_header:
| IDENTIFIER LEFT_PAREN param RIGHT_PAREN {($1,List.rev $3)}


/*type funcDecParamList = (valRef*typedefStruct*string) list*/
param:
| rec_param param_passing_indicator type_spec IDENTIFIER {($2,$3,$4)::$1}
| {[]}

/*type funcDecParamList = (valRef*typedefStruct*string)*/

rec_param:
| param COMMA {$1}
| {[]}

/* type valRef  */
param_passing_indicator:
| VAL {Val}
| REF {Ref}


/*typedefStruct*/
variable_definition:
| variable_definition type_spec IDENTIFIER SEMICOLON { SingleTypeTermWithIdent($3,$2)::$1 }
| {[]}

/*procedure , stmt list*/

/* stmt list */
procedure_body:
| atomic_stmt SEMICOLON rec_procedure_body {$1::$3}
| compound_stmt rec_procedure_body {$1::$2}

rec_procedure_body:
| procedure_body {$1}
| {[]}

/* stmt */
atomic_stmt:
| lvalue EQ_COL rvalue { Assign($1,$3)}
| READ lvalue { Read($2) }
| WRITE expr { Write($2) }
| IDENTIFIER LEFT_PAREN expr_list RIGHT_PAREN { Method($1,$3) }

/* stmt */
compound_stmt:
| IF expr THEN stmt_list else_block FI {IfDec($2,$4,$5)}
| WHILE expr DO stmt_list OD {WhileDec($2,$4)}


/* object.field*/
lvalue:
| IDENTIFIER { LId($1) }
| lvalue DOT IDENTIFIER { LField($1,$3) }

/* rvalue*/
rvalue:
| expr { Rexpr($1) }
| LEFT_BRACE field_init RIGHT_BRACE { Rstmts(List.rev $2) }
| LEFT_BRACE RIGHT_BRACE { Rempty }

/* rvalue list */
field_init:
| rec_field_init IDENTIFIER EQ rvalue {Rassign($2,$4)::$1}

rec_field_init:
| field_init COMMA {$1}
| {[]}

expr:
| lvalue { Elval($1) }
| const { $1 }
| LEFT_PAREN expr RIGHT_PAREN { Ebracket($2) }
| expr PLUS expr { Ebinop($1,Op_add,$3) }
| expr MINUS expr { Ebinop($1,Op_sub,$3) }
| expr MUL expr { Ebinop($1,Op_mul,$3) }
| expr DIV expr { Ebinop($1,Op_div,$3) }
| expr EQ expr { Ebinop($1,Op_eq,$3) }
| expr NEQ expr { Ebinop($1,Op_neq,$3) }
| expr LT expr { Ebinop($1,Op_lt,$3) }
| expr GT expr { Ebinop($1,Op_gt,$3) }
| expr LTE expr { Ebinop($1,Op_lte,$3) }
| expr GTE expr { Ebinop($1,Op_gte,$3) }
| expr AND expr { Ebinop($1,Op_and,$3) }
| expr OR expr { Ebinop($1,Op_or,$3) }
| NOT expr { Eunop(Op_not,$2) }
| UMINUS expr { Eunop(Op_minus,$2) }

/* expr list */
expr_list:
| expr rec_expr_list { $1::$2 }
| {[]}

rec_expr_list:
| COMMA expr_list { $2 }
| {[]}

stmt_list:
| procedure_body {$1}

else_block:
| ELSE stmt_list {$2}
| {[]}

const:
| BOOL_VAL { Ebool($1) }
| INT_VAL { Eint($1) }
| STRING_VAL { Eident($1) }
============================================
src/bean_lex.mll
02:01:57_Monday_11_April_2016
============================================
{
open Bean_parse
let line_num = ref 0

exception LexFail of Lexing.lexbuf


let lex_fail lexbuf = raise (LexFail lexbuf)
}

let apostro = '''
let digit = ['0' - '9']
let alpha = ['a' - 'z' 'A' - 'Z']
let alnum = alpha | digit (* unused *)
let digits = digit+ (* unused *)
let underscore = '_'
let ident = (alpha|underscore)(alpha|underscore|apostro)* (* to be changed to (alpha|underscore)(alpha|underscore|apostro)* *)
let typedef_value_init = (ident ':' ident) (* unused *)
let function_value_init = ident ident (* unused *)

let comment = '#'[^'\n']*'\n'

rule token = parse
    [' ' '\t']    { token lexbuf }     (* skip blanks *)
  | '\n'          { incr line_num; Lexing.new_line lexbuf ; token lexbuf }
  (*| '-'?['0'-'9']+ as lxm { IPrintf.printf "meet typedef \n" ;flush stdout;NT_CONST(int_of_string lxm) }*)
  | '-'?['0'-'9']+ as lxm{INT_VAL(int_of_string(lxm)) }
  (* keywords *)
  | comment {incr line_num;token lexbuf }
  | ':' { flush stdout;COLON }
  | '{' { LEFT_BRACE }
  | '}' { RIGHT_BRACE }
  | "typedef" {TYPEDEF("typedef") }
  | "proc" {ROC}
  (*| typedef_value_init  as temp{ Printf.printf "meet typedef_value_init => %s \n" temp;flush stdout;TYPEDEF_VALUE_INIT }*)
  | ',' { COMMA }
  | '.' { DOT }
  | "end" { END }
  | "val" { VAL }
  | "ref" {REF }
  | '(' { LEFT_PAREN }
  | ')' { RIGHT_PAREN }
  | "while" {WHILE }
  | "do" { DO }
  | "od" { OD }
  | "if" { IF }
  | "then" {THEN }
  | "else" {ELSE }
  | "fi" {FI} 
  | "bool" {BOOL }
  | "int" { INT }
  (*| "true" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL true }*)
  | "true" {BOOL_VAL true}
  (*| "false" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL false }*)
  | "false" {BOOL_VAL false}
  | "read" { READ }
  | "write" { WRITE }
  (*| ":=" { Printf.printf "meet typedef \n" ;flush stdout;ASSIGN }*)
  | ":=" {EQ_COL}
  (*| '(' { LPAREN }*)
  (*| ')' { RPAREN }*)
  | "!=" {NEQ }
  | "<="{ LTE }
  | ">="{ GTE }
  | '=' { EQ }
  | '<' { LT }
  | '+' { PLUS }
  | '-' { MINUS }
  | '*' { MUL }
  | ';' { SEMICOLON }
  | '>' { GT}
  | '"' [^ '"' '\t' '\n' '\r' ]* '"' as lxm{STRING_VAL(lxm)}
  (*| ident as lxm { IDENT lxm }*)
  | ident as lxm{  lxm ;flush stdout;IDENTIFIER(lxm) }
  | eof { flush stdout;EOF }
  | _   { lex_fail lexbuf }
============================================
src/Makefile
02:01:58_Monday_11_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o ./bean *.byte
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/bean.ml
02:01:57_Monday_11_April_2016
============================================
open Bean_lex
module P = Bean_parse

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  try
      (* Open the input file *)
      let infile = match !infile_name with
      | None -> stdin
      | Some fname -> begin Printf.printf "fname => %s \n" fname;open_in fname end in
      (* Initialize lexing buffer *)
      let lexbuf = Lexing.from_channel infile in
      (* Call the parser *)
      let prog = Bean_parse.start_state Bean_lex.token lexbuf in
      match !mode with
      | PrettyPrint ->
        Bean_pprint.print_program Format.std_formatter prog 
      | Compile -> Printf.eprintf "Sorry, cannot compile yet."
  with
      | Parsing.Parse_error -> Printf.eprintf "Syntax error\n"
      | LexFail lexbuf -> let position = Lexing.lexeme_start_p lexbuf in
          Printf.eprintf "Illegal Character on line %d, col %d.\n" position.Lexing.pos_lnum
          (position.Lexing.pos_cnum - position.Lexing.pos_bol)

let _ = main ()
============================================
src/bean_pprint.mli
02:03:11_Monday_11_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/Makefile
02:03:11_Monday_11_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o ./bean *.byte
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/bean_parse.mly
02:03:11_Monday_11_April_2016
============================================
/* ocamlyacc parser for bean */
%{
open Bean_ast
%}

%token <bool> BOOL_VAL
%token <int> INT_VAL
%token <string> STRING_VAL
%token WRITE READ
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token PLUS MINUS MUL DIV
%token UMINUS
%token COLON
%token SEMICOLON
%token AND OR NOT
%token EOF


%token <string> IDENTIFIER
%token LEFT_PAREN RIGHT_PAREN
%token <string> TYPEDEF
%token TYPEDEF_VALUE_INIT
%token DOT
%token COMMA
%token END
%token VAL
%token REF
%token LEFT_BRACE RIGHT_BRACE
%token WHILE DO OD
%token IF THEN ELSE FI
%token BOOL INT
%token PROC
%token EQ_COL
%left OR
%left AND
%nonassoc EQ NEQ LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right EQ_COL
%nonassoc NOT UMINUS

%type <Bean_ast.program> start_state

%start start_state
%%


/*
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
*/

start_state:
| type_definition procedure_definition {{typedefs = List.rev $1;funcdefs = List.rev $2}}

/*typdef ? identifier*/
type_definition:
| type_definition TYPEDEF type_spec IDENTIFIER {($3,$4)::$1}
| {[]}

type_spec:
| primitive_type {$1}
| IDENTIFIER {SingleTypeTerm((IdentType $1))}
/*typdef {?} identifier*/
| LEFT_BRACE field_definition RIGHT_BRACE {ListTypeTerm( List.rev $2)}

primitive_type:
| BOOL {SingleTypeTerm(Bool)}
| INT {SingleTypeTerm(Int)}

field_definition:
| rec_field_definition IDENTIFIER COLON type_spec {SingleTypeTermWithIdent($2,$4)::$1}

rec_field_definition:
| field_definition COMMA {$1}
| {[]}








/* At least one procedure required */
/* (functionDeclaration * typedefStruct  * stmt list) list */
procedure_definition:
| rec_procedure_definition PROC procedure_header variable_definition procedure_body END {($3,List.rev $4,$5)::$1}

/* (functionDeclaration * typedefStruct  * stmt list) list */
rec_procedure_definition:
| procedure_definition {$1}
| {[]}

/*type functionDeclaration = (string*funcDecParamList)*/
/*type funcDecParamList = (valRef*typedefStruct*string) list*/
procedure_header:
| IDENTIFIER LEFT_PAREN param RIGHT_PAREN {($1,List.rev $3)}


/*type funcDecParamList = (valRef*typedefStruct*string) list*/
param:
| rec_param param_passing_indicator type_spec IDENTIFIER {($2,$3,$4)::$1}
| {[]}

/*type funcDecParamList = (valRef*typedefStruct*string)*/

rec_param:
| param COMMA {$1}
| {[]}

/* type valRef  */
param_passing_indicator:
| VAL {Val}
| REF {Ref}


/*typedefStruct*/
variable_definition:
| variable_definition type_spec IDENTIFIER SEMICOLON { SingleTypeTermWithIdent($3,$2)::$1 }
| {[]}

/*procedure , stmt list*/

/* stmt list */
procedure_body:
| atomic_stmt SEMICOLON rec_procedure_body {$1::$3}
| compound_stmt rec_procedure_body {$1::$2}

rec_procedure_body:
| procedure_body {$1}
| {[]}

/* stmt */
atomic_stmt:
| lvalue EQ_COL rvalue { Assign($1,$3)}
| READ lvalue { Read($2) }
| WRITE expr { Write($2) }
| IDENTIFIER LEFT_PAREN expr_list RIGHT_PAREN { Method($1,$3) }

/* stmt */
compound_stmt:
| IF expr THEN stmt_list else_block FI {IfDec($2,$4,$5)}
| WHILE expr DO stmt_list OD {WhileDec($2,$4)}


/* object.field*/
lvalue:
| IDENTIFIER { LId($1) }
| lvalue DOT IDENTIFIER { LField($1,$3) }

/* rvalue*/
rvalue:
| expr { Rexpr($1) }
| LEFT_BRACE field_init RIGHT_BRACE { Rstmts(List.rev $2) }
| LEFT_BRACE RIGHT_BRACE { Rempty }

/* rvalue list */
field_init:
| rec_field_init IDENTIFIER EQ rvalue {Rassign($2,$4)::$1}

rec_field_init:
| field_init COMMA {$1}
| {[]}

expr:
| lvalue { Elval($1) }
| const { $1 }
| LEFT_PAREN expr RIGHT_PAREN { Ebracket($2) }
| expr PLUS expr { Ebinop($1,Op_add,$3) }
| expr MINUS expr { Ebinop($1,Op_sub,$3) }
| expr MUL expr { Ebinop($1,Op_mul,$3) }
| expr DIV expr { Ebinop($1,Op_div,$3) }
| expr EQ expr { Ebinop($1,Op_eq,$3) }
| expr NEQ expr { Ebinop($1,Op_neq,$3) }
| expr LT expr { Ebinop($1,Op_lt,$3) }
| expr GT expr { Ebinop($1,Op_gt,$3) }
| expr LTE expr { Ebinop($1,Op_lte,$3) }
| expr GTE expr { Ebinop($1,Op_gte,$3) }
| expr AND expr { Ebinop($1,Op_and,$3) }
| expr OR expr { Ebinop($1,Op_or,$3) }
| NOT expr { Eunop(Op_not,$2) }
| UMINUS expr { Eunop(Op_minus,$2) }

/* expr list */
expr_list:
| expr rec_expr_list { $1::$2 }
| {[]}

rec_expr_list:
| COMMA expr_list { $2 }
| {[]}

stmt_list:
| procedure_body {$1}

else_block:
| ELSE stmt_list {$2}
| {[]}

const:
| BOOL_VAL { Ebool($1) }
| INT_VAL { Eint($1) }
| STRING_VAL { Eident($1) }
============================================
src/bean.ml
02:04:20_Monday_11_April_2016
============================================
open Bean_lex
module P = Bean_parse

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  try
      (* Open the input file *)
      let infile = match !infile_name with
      | None -> stdin
      | Some fname -> begin Printf.printf "fname => %s \n" fname;open_in fname end in
      (* Initialize lexing buffer *)
      let lexbuf = Lexing.from_channel infile in
      (* Call the parser *)
      let prog = Bean_parse.start_state Bean_lex.token lexbuf in
      match !mode with
      | PrettyPrint ->
        Bean_pprint.print_program Format.std_formatter prog 
      | Compile -> Printf.eprintf "Sorry, cannot compile yet."
  with
      | Parsing.Parse_error -> Printf.eprintf "Syntax error\n"
      | LexFail lexbuf -> let position = Lexing.lexeme_start_p lexbuf in
          Printf.eprintf "Illegal Character on line %d, col %d.\n" position.Lexing.pos_lnum
          (position.Lexing.pos_cnum - position.Lexing.pos_bol)

let _ = main ()
============================================
src/Makefile
02:04:20_Monday_11_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o ./bean *.byte
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/bean_lex.mll
02:04:20_Monday_11_April_2016
============================================
{
open Bean_parse
let line_num = ref 0

exception LexFail of Lexing.lexbuf


let lex_fail lexbuf = raise (LexFail lexbuf)
}

let apostro = '''
let digit = ['0' - '9']
let alpha = ['a' - 'z' 'A' - 'Z']
let alnum = alpha | digit (* unused *)
let digits = digit+ (* unused *)
let underscore = '_'
let ident = (alpha|underscore)(alpha|underscore|apostro)* (* to be changed to (alpha|underscore)(alpha|underscore|apostro)* *)
let typedef_value_init = (ident ':' ident) (* unused *)
let function_value_init = ident ident (* unused *)

let comment = '#'[^'\n']*'\n'

rule token = parse
    [' ' '\t']    { token lexbuf }     (* skip blanks *)
  | '\n'          { incr line_num; Lexing.new_line lexbuf ; token lexbuf }
  (*| '-'?['0'-'9']+ as lxm { IPrintf.printf "meet typedef \n" ;flush stdout;NT_CONST(int_of_string lxm) }*)
  | '-'?['0'-'9']+ as lxm{INT_VAL(int_of_string(lxm)) }
  (* keywords *)
  | comment {incr line_num;token lexbuf }
  | ':' { flush stdout;COLON }
  | '{' { LEFT_BRACE }
  | '}' { RIGHT_BRACE }
  | "typedef" {TYPEDEF("typedef") }
  | "proc" {PROC}
  (*| typedef_value_init  as temp{ Printf.printf "meet typedef_value_init => %s \n" temp;flush stdout;TYPEDEF_VALUE_INIT }*)
  | ',' { COMMA }
  | '.' { DOT }
  | "end" { END }
  | "val" { VAL }
  | "ref" {REF }
  | '(' { LEFT_PAREN }
  | ')' { RIGHT_PAREN }
  | "while" {WHILE }
  | "do" { DO }
  | "od" { OD }
  | "if" { IF }
  | "then" {THEN }
  | "else" {ELSE }
  | "fi" {FI} 
  | "bool" {BOOL }
  | "int" { INT }
  (*| "true" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL true }*)
  | "true" {BOOL_VAL true}
  (*| "false" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL false }*)
  | "false" {BOOL_VAL false}
  | "read" { READ }
  | "write" { WRITE }
  (*| ":=" { Printf.printf "meet typedef \n" ;flush stdout;ASSIGN }*)
  | ":=" {EQ_COL}
  (*| '(' { LPAREN }*)
  (*| ')' { RPAREN }*)
  | "!=" {NEQ }
  | "<="{ LTE }
  | ">="{ GTE }
  | '=' { EQ }
  | '<' { LT }
  | '+' { PLUS }
  | '-' { MINUS }
  | '*' { MUL }
  | ';' { SEMICOLON }
  | '>' { GT}
  | '"' [^ '"' '\t' '\n' '\r' ]* '"' as lxm{STRING_VAL(lxm)}
  (*| ident as lxm { IDENT lxm }*)
  | ident as lxm{IDENTIFIER(lxm) }
  | eof { EOF }
  | _   { lex_fail lexbuf }
============================================
src/bean_pprint.ml
02:04:20_Monday_11_April_2016
============================================
open Bean_ast
open Format

let print_program fmt prog = (Printf.printf " \nwhat is in side => \n" ;
	Format.set_max_indent 100;
	printTypedefList fmt prog.typedefs;
	printFuncdefList fmt prog.funcdefs
)
============================================
src/Makefile.depend
02:04:20_Monday_11_April_2016
============================================
bean.cmo :
bean.cmx :
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi :
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_pprint.cmi
bean_pprint.cmx : bean_pprint.cmi
bean.cmo :
bean.cmx :
============================================
src/bean.ml
02:05:40_Monday_11_April_2016
============================================
open Bean_lex
module P = Bean_parse

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  try
      (* Open the input file *)
      let infile = match !infile_name with
      | None -> stdin
      | Some fname -> begin Printf.printf "fname => %s \n" fname;open_in fname end in
      (* Initialize lexing buffer *)
      let lexbuf = Lexing.from_channel infile in
      (* Call the parser *)
      let prog = Bean_parse.start_state Bean_lex.token lexbuf in
      match !mode with
      | PrettyPrint ->
        Bean_pprint.print_program Format.std_formatter prog 
      | Compile -> Printf.eprintf "Sorry, cannot compile yet."
  with
      | Parsing.Parse_error -> Printf.eprintf "Syntax error\n"
      | LexFail lexbuf -> let position = Lexing.lexeme_start_p lexbuf in
          Printf.eprintf "Illegal Character on line %d, col %d.\n" position.Lexing.pos_lnum
          (position.Lexing.pos_cnum - position.Lexing.pos_bol)

let _ = main ()
============================================
src/bean_pprint.ml
02:05:40_Monday_11_April_2016
============================================
open Bean_ast
open Format

let print_program fmt prog = (
	Format.set_max_indent 100;
	printTypedefList fmt prog.typedefs;
	printFuncdefList fmt prog.funcdefs
)
============================================
src/bean_lex.mll
02:05:40_Monday_11_April_2016
============================================
{
open Bean_parse
let line_num = ref 0

exception LexFail of Lexing.lexbuf


let lex_fail lexbuf = raise (LexFail lexbuf)
}

let apostro = '''
let digit = ['0' - '9']
let alpha = ['a' - 'z' 'A' - 'Z']
let alnum = alpha | digit (* unused *)
let digits = digit+ (* unused *)
let underscore = '_'
let ident = (alpha|underscore)(alpha|underscore|apostro)* (* to be changed to (alpha|underscore)(alpha|underscore|apostro)* *)
let typedef_value_init = (ident ':' ident) (* unused *)
let function_value_init = ident ident (* unused *)

let comment = '#'[^'\n']*'\n'

rule token = parse
    [' ' '\t']    { token lexbuf }     (* skip blanks *)
  | '\n'          { incr line_num; Lexing.new_line lexbuf ; token lexbuf }
  (*| '-'?['0'-'9']+ as lxm { IPrintf.printf "meet typedef \n" ;flush stdout;NT_CONST(int_of_string lxm) }*)
  | '-'?['0'-'9']+ as lxm{INT_VAL(int_of_string(lxm)) }
  (* keywords *)
  | comment {incr line_num;token lexbuf }
  | ':' { flush stdout;COLON }
  | '{' { LEFT_BRACE }
  | '}' { RIGHT_BRACE }
  | "typedef" {TYPEDEF("typedef") }
  | "proc" {PROC}
  (*| typedef_value_init  as temp{ Printf.printf "meet typedef_value_init => %s \n" temp;flush stdout;TYPEDEF_VALUE_INIT }*)
  | ',' { COMMA }
  | '.' { DOT }
  | "end" { END }
  | "val" { VAL }
  | "ref" {REF }
  | '(' { LEFT_PAREN }
  | ')' { RIGHT_PAREN }
  | "while" {WHILE }
  | "do" { DO }
  | "od" { OD }
  | "if" { IF }
  | "then" {THEN }
  | "else" {ELSE }
  | "fi" {FI} 
  | "bool" {BOOL }
  | "int" { INT }
  (*| "true" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL true }*)
  | "true" {BOOL_VAL true}
  (*| "false" { Printf.printf "meet typedef \n" ;flush stdout;BOOL_VAL false }*)
  | "false" {BOOL_VAL false}
  | "read" { READ }
  | "write" { WRITE }
  (*| ":=" { Printf.printf "meet typedef \n" ;flush stdout;ASSIGN }*)
  | ":=" {EQ_COL}
  (*| '(' { LPAREN }*)
  (*| ')' { RPAREN }*)
  | "!=" {NEQ }
  | "<="{ LTE }
  | ">="{ GTE }
  | '=' { EQ }
  | '<' { LT }
  | '+' { PLUS }
  | '-' { MINUS }
  | '*' { MUL }
  | ';' { SEMICOLON }
  | '>' { GT}
  | '"' [^ '"' '\t' '\n' '\r' ]* '"' as lxm{STRING_VAL(lxm)}
  (*| ident as lxm { IDENT lxm }*)
  | ident as lxm{IDENTIFIER(lxm) }
  | eof { EOF }
  | _   { lex_fail lexbuf }
============================================
src/bean_ast.ml
02:05:40_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty


type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)




type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref


type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program

(*
let printBeantype beanTypeData = match beanTypeData with
| Bool -> Printf.printf " Bool "
| Int -> Printf.printf " Int "
| IdentType(s) ->  Printf.printf " string => %s" s

let rec printTypedefStruct typedefStructData = match typedefStructData with
| SingleTypeTerm(id , tp) -> (Printf.printf "id => %s , type => \n" id ; printBeantype tp)
| ListTypeTerm(id , tps) -> (Printf.printf "Listype name => %s " id;List.iter (printTypedefStruct) tps)

let rec printTypedefs typedefData = match typedefData with
| [] -> Printf.printf "Empty \n "
| (hstructList,hid)::t -> ( Printf.printf "typedef name => %s : \n  " hid; List.iter (printTypedefStruct) hstructList ; printTypedefs t )

*)

(* Print typedef *)

let printBeanType fmt (btype,suffix) =  match btype with
| Bool -> Format.fprintf fmt "bool%s" suffix 
| Int ->  Format.fprintf fmt "int%s" suffix  
| IdentType(ident) -> Format.fprintf fmt "%s%s" ident suffix

(* mode = 1 ==> in typedef *)
let rec printTypedefStruct fmt (arrangeMode,typedefStructData) = match typedefStructData with
| SingleTypeTerm (btype) -> if arrangeMode = 1 then printBeanType fmt (btype,"") else printBeanType fmt (btype," ")
| SingleTypeTermWithIdent (ident,nestTypedefStructData) ->
  if arrangeMode = 1 then Format.fprintf fmt "%s : %a" ident printTypedefStruct (arrangeMode,nestTypedefStructData)
  else Format.fprintf fmt "%a%s" printTypedefStruct (arrangeMode,nestTypedefStructData) ident
| ListTypeTerm (listTypedefStructData) ->(Format.fprintf fmt "{"  ;
  List.iter (fun x -> if x = List.nth listTypedefStructData ((List.length listTypedefStructData)-1) 
    then printTypedefStruct fmt (arrangeMode,x)
    else (printTypedefStruct fmt (arrangeMode,x) ; Format.fprintf fmt ", ")) listTypedefStructData;
  Format.fprintf fmt "}" )
| TypedefEnd -> Format.fprintf fmt "end with type def \n"

let printSingleTypedef fmt singleTypedefData = let arrangeMode = 1 in match singleTypedefData with
| (typedefStruct,ident) -> Format.fprintf fmt "typedef %a %s\n" printTypedefStruct (arrangeMode,typedefStruct) ident 
 

let printTypedefList fmt typedefDataList = (Format.fprintf fmt "@[";
  List.iter (printSingleTypedef fmt) typedefDataList;
  Format.fprintf fmt "@]@.")




(* Print method delc*)


let printFuncIndicator fmt funcIndicator = match funcIndicator with
| Val -> Format.fprintf fmt "val "
| Ref -> Format.fprintf fmt "ref "

let printFuncparams fmt singleFuncparamData =  let arrangeMode = 1 in match singleFuncparamData with
| (funcIndicator,typedefStruct,ident) -> Format.fprintf fmt  "%a%a %s"  printFuncIndicator funcIndicator printTypedefStruct (arrangeMode,typedefStruct) ident

let printFuncheader fmt funcheaderData = match funcheaderData with
| (funcname,funcparams) -> (Format.fprintf fmt "%s(" funcname ;
List.iter (fun x -> if x = List.nth funcparams ((List.length funcparams)-1) 
    then printFuncparams fmt x
    else (printFuncparams fmt x ; Format.fprintf fmt ", ")) funcparams;
    Format.fprintf fmt ")")


let printFuncVardef fmt funcVardefData = let arrangeMode = 2 in List.iter (fun x -> 
   if x = List.nth funcVardefData ((List.length funcVardefData)-1)
   then (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";")
   else (printTypedefStruct fmt (arrangeMode,x); Format.fprintf fmt ";@ "))
  funcVardefData


(*//TODO *)
let rec printLvalue fmt singleLvalue = match singleLvalue with
| LId(ident) -> Format.fprintf fmt "%s" ident
| LField(recLvalue,ident) -> (Format.fprintf fmt "%s." ident; printLvalue fmt recLvalue)
| LvalueNone -> Format.fprintf fmt "Empty lvalue"

let printBinop fmt singleBinop = match singleBinop with
| Op_add -> Format.fprintf fmt  " + "
| Op_sub -> Format.fprintf fmt  " - "
| Op_mul -> Format.fprintf fmt  " * "
| Op_div -> Format.fprintf fmt " / " 
| Op_eq -> Format.fprintf fmt  " = "
| Op_lt -> Format.fprintf fmt  " < "
| Op_gt -> Format.fprintf fmt  " > "
| Op_neq -> Format.fprintf fmt  " != "
| Op_lte -> Format.fprintf fmt  " <= "
| Op_gte -> Format.fprintf fmt  " >= "
| Op_and -> Format.fprintf fmt  " and "
| Op_or -> Format.fprintf fmt  " or "

let printUnop fmt singleUnop = match singleUnop with
| Op_minus -> Format.fprintf fmt "-"
| Op_not -> Format.fprintf fmt "!"

let rec printExpr fmt singleExpr = match singleExpr with
| Ebool(bool_val) -> Format.fprintf fmt "%B" bool_val
| Eint(int_val) -> Format.fprintf fmt "%d" int_val
| Elval(lvalue) -> printLvalue fmt lvalue
| Ebinop(expr_one,binop,expr_two) -> (printExpr fmt expr_one;
  printBinop fmt binop; printExpr fmt expr_two)
| Eunop(unop,expr) -> (printUnop fmt unop ; printExpr fmt expr)
| Eident(ident) -> Format.fprintf fmt "%s " ident
| Ebracket(expr) -> (Format.fprintf fmt "( " ; printExpr fmt expr  ;Format.fprintf fmt " ) ")


let rec printRvalue fmt singleRvalue = match singleRvalue with
| Rexpr(expr) -> printExpr fmt expr
| RField(rvalue,expr) -> (printRvalue fmt rvalue;
  printExpr fmt expr)
| Rassign(str,rvalue) -> (Format.fprintf fmt "%s = " str;
  printRvalue fmt rvalue)
| Rstmts(rvalueList) -> (Format.fprintf fmt "{";
  List.iter (fun x ->( if x = List.nth rvalueList ((List.length rvalueList)-1) 
  then printRvalue fmt x
  else (printRvalue fmt x ;Format.fprintf fmt ", ") )) rvalueList;
  Format.fprintf fmt "}")
| Rempty -> Format.fprintf fmt "Empty Rvalue "

let getIdent identNum = String.make identNum ' '

let printEndStmt fmt isLast lastStr = match isLast with
  | true -> Format.fprintf fmt  "%s" lastStr
  | false -> Format.fprintf fmt  "%s@ " lastStr

let rec printStmt fmt (initIdent,isLast,singleStmt) = match singleStmt with

| Assign(lvalue, rvalue) -> (printLvalue fmt lvalue;
  Format.fprintf fmt  " := ";
  printRvalue fmt rvalue;
  printEndStmt fmt isLast ";")

| AssignRvalueList(lvalue,rvalueList) ->(printLvalue fmt lvalue;
  Format.fprintf fmt  "={";
  List.iter (printRvalue fmt) rvalueList;
  Format.fprintf fmt "}";
  printEndStmt fmt isLast ";")

| Read(lvalue) -> (Format.fprintf fmt  "read ";
  printLvalue fmt lvalue;
  printEndStmt fmt isLast ";")

| Write(expr) -> (Format.fprintf fmt  "write ";
  printExpr fmt expr;
  printEndStmt fmt isLast ";")

| StmtNone -> Format.fprintf fmt "StmtNone"

| Method(methodname, paramList) -> (Format.fprintf fmt "%s(" methodname ;
  List.iter (fun x -> if x = List.nth paramList ((List.length paramList)-1) 
  then printExpr fmt x
  else (printExpr fmt x; Format.fprintf fmt ", " )) paramList;
  Format.fprintf fmt ")";
  printEndStmt fmt isLast ";")

| VarDec(beantype, ident) -> (printBeanType fmt (beantype,"");
  Format.fprintf fmt "%s " ident;
  printEndStmt fmt isLast ";")

| WhileDec(expr, stmtList) ->(Format.fprintf fmt "while %a do @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth stmtList ((List.length stmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) stmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt"@ od";
  printEndStmt fmt isLast "")

| IfDec(expr, thenStmtList, elseStmtList) -> (Format.fprintf fmt "if %a then @ " printExpr expr;
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth thenStmtList ((List.length thenStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) thenStmtList;
  Format.fprintf fmt " @]";
  if (List.length elseStmtList) != 0 then (Format.fprintf fmt " @ ";Format.fprintf fmt "else @ ");
  Format.fprintf fmt "@[<v %d>%s" initIdent (getIdent initIdent);
  List.iter (fun x -> if x = List.nth elseStmtList ((List.length elseStmtList)-1) 
    then printStmt fmt (initIdent,true,x)
    else printStmt fmt (initIdent,false,x)) elseStmtList;
  Format.fprintf fmt " @]";
  Format.fprintf fmt  "@ fi";
  printEndStmt fmt isLast "")

let printFuncBody fmt funcBodyData = let initIdentFactor = 4 in List.iter (fun x -> if x = List.nth funcBodyData ((List.length funcBodyData)-1) 
    then printStmt fmt (initIdentFactor,true,x)
    else printStmt fmt (initIdentFactor,false,x)) funcBodyData
(*
let printSingleFuncdef fmt initIdent initIdentFactor singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) -> Format.fprintf fmt "@[proc %a @ %a @ @ %a end@]@." printFuncheader (initIdent,initIdentFactor,funcheader) printFuncVardef (initIdent,initIdentFactor,funcvardef)  printFuncBody (initIdent,initIdentFactor,funcbody)
*)
let printSingleFuncdef fmt singleFuncdefData = match singleFuncdefData with
| (funcheader,funcvardef,funcbody) ->(Format.fprintf fmt "proc %a" printFuncheader funcheader;
  if (List.length funcvardef) !=0 then Format.fprintf fmt " @ %a " printFuncVardef funcvardef;
  if (List.length funcbody) != 0 then Format.fprintf fmt " @ @ %a " printFuncBody funcbody;
  Format.fprintf fmt "\nend\n\n")

let printFuncdefList fmt funcdefDataList = let iniIdent = 4 in (Format.fprintf fmt "@[<v %d>" iniIdent ; List.iter (printSingleFuncdef fmt) funcdefDataList ;Format.fprintf fmt "@] " )









============================================
src/bean_pprint.mli
02:05:40_Monday_11_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/Makefile.depend
02:16:27_Monday_11_April_2016
============================================
bean.cmo :
bean.cmx :
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi :
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_pprint.cmi
bean_pprint.cmx : bean_pprint.cmi
bean.cmo :
bean.cmx :
============================================
src/bean.ml
02:16:27_Monday_11_April_2016
============================================
open Bean_lex
module P = Bean_parse

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  try
      (* Open the input file *)
      let infile = match !infile_name with
      | None -> stdin
      | Some fname -> begin Printf.printf "fname => %s \n" fname;open_in fname end in
      (* Initialize lexing buffer *)
      let lexbuf = Lexing.from_channel infile in
      (* Call the parser *)
      let prog = Bean_parse.start_state Bean_lex.token lexbuf in
      match !mode with
      | PrettyPrint ->
        Bean_pprint.print_program Format.std_formatter prog 
      | Compile -> Printf.eprintf "Sorry, cannot compile yet."
  with
      | Parsing.Parse_error -> Printf.eprintf "Syntax error\n"
      | LexFail lexbuf -> let position = Lexing.lexeme_start_p lexbuf in
          Printf.eprintf "Illegal Character on line %d, col %d.\n" position.Lexing.pos_lnum
          (position.Lexing.pos_cnum - position.Lexing.pos_bol)

let _ = main ()
============================================
src/bean_ast.mli
02:16:27_Monday_11_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Keep aliases intact for pretty printing. *)
type beantype =
  | Bool
  | Int
  | IdentType of string 

type typedefStruct =
  |SingleTypeTerm of beantype
  |SingleTypeTermWithIdent of (ident * typedefStruct)
  |ListTypeTerm of typedefStruct list
  |TypedefEnd
type typedef = typedefStruct list

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)
  | LvalueNone

type binop =
  | Op_add | Op_sub | Op_mul | Op_div
  | Op_eq | Op_lt | Op_gt | Op_neq | Op_lte | Op_gte
  | Op_and | Op_or

type unop =
  | Op_minus | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)
  | Eident of string
  | Ebracket of expr

(* Will need to AST elements with additional data.  *)
type rvalue =
  | Rexpr of expr
  | RField of (rvalue * expr)
  | Rassign of (string * rvalue)
  | Rstmts of rvalue list 
  | Rempty

type paramList = expr list

type stmt = 
  | Assign of (lvalue * rvalue)
  | AssignRvalueList of (lvalue * rvalue list)
  | Read of lvalue
  | Write of expr
  | StmtNone
  | Method of (string * paramList)
  | VarDec of (beantype * string)
  | WhileDec of (expr * stmt list)
  | IfDec of (expr * stmt list * stmt list)


type decl = (ident * beantype)
(*
type stmt =  
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of expr
  | Test
*)

type valRef = 
|Val
|Ref



type funcDecParamList = (valRef*typedefStruct*string) list


type functionDeclaration = (string*funcDecParamList)
(*
type program = {
  typedefs : (typedef*ident) list;
  funcdefs : (functionDeclaration*stmst list*stmt list) list
}
*)
type program = {
  typedefs : (typedefStruct*ident) list;
  funcdefs : (functionDeclaration*typedefStruct list*stmt list) list
}
type t = program
(*
val printBeantype : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit 
val printTypedefs : (typedefStruct list * ident) list -> unit
*)
(*
val printBeanType : beantype -> unit 
val printSingleTypeDef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit 
*)
(*
val printBeanType : beantype -> unit 
val printTypedefStruct : typedefStruct -> unit
val printSingleTypedef : typedefStruct * ident -> unit
val printTypedefList : (typedefStruct * ident) list -> unit
*)
(*
val printFuncIndicator : valRef -> unit
val printFuncparams : valRef * typedefStruct * ident -> unit
val printFuncheader : ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : typedefStruct list -> unit
val printLvalue : lvalue -> unit
val printBinop : binop -> unit
val printUnop : unop -> unit
val printExpr : expr -> unit
val printRvalue : rvalue -> unit
val printStmt : stmt -> unit
val printFuncBody : stmt list -> unit
val printSingleFuncdef : (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit 
val printFuncdefList : ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit*)
val printBeanType : Format.formatter -> beantype * string -> unit
val printTypedefStruct : Format.formatter -> int * typedefStruct -> unit
val printSingleTypedef : Format.formatter -> typedefStruct * ident -> unit
val printTypedefList : Format.formatter -> (typedefStruct * ident) list -> unit
val printFuncIndicator : Format.formatter -> valRef -> unit
val printFuncparams : Format.formatter -> valRef * typedefStruct * ident -> unit
val printFuncheader : Format.formatter -> ident * (valRef * typedefStruct * ident) list -> unit
val printFuncVardef : Format.formatter -> typedefStruct list -> unit
val printLvalue : Format.formatter -> lvalue -> unit
val printBinop : Format.formatter -> binop -> unit
val printUnop : Format.formatter -> unop -> unit
val printExpr : Format.formatter -> expr -> unit
val printRvalue : Format.formatter -> rvalue -> unit
val getIdent : int -> ident
val printEndStmt : Format.formatter -> bool -> ident -> unit
val printStmt : Format.formatter -> int * bool * stmt -> unit
val printFuncBody : Format.formatter -> stmt list -> unit
val printSingleFuncdef : Format.formatter -> (ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list -> unit
val printFuncdefList : Format.formatter -> ((ident * (valRef * typedefStruct * ident) list) * typedefStruct list * stmt list) list -> unit============================================
src/bean.ml
02:18:31_Monday_11_April_2016
============================================
open Bean_lex
module P = Bean_parse

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  try
      (* Open the input file *)
      let infile = match !infile_name with
      | None -> stdin
      | Some fname -> begin Printf.printf "fname => %s \n" fname;open_in fname end in
      (* Initialize lexing buffer *)
      let lexbuf = Lexing.from_channel infile in
      (* Call the parser *)
      let prog = Bean_parse.start_state Bean_lex.token lexbuf in
      match !mode with
      | PrettyPrint ->
        Bean_pprint.print_program Format.std_formatter prog 
      | Compile -> Printf.eprintf "Sorry, cannot compile yet."
  with
      | Parsing.Parse_error -> Printf.eprintf "Syntax error\n"
      | LexFail lexbuf -> let position = Lexing.lexeme_start_p lexbuf in
          Printf.eprintf "Illegal Character on line %d, col %d.\n" position.Lexing.pos_lnum
          (position.Lexing.pos_cnum - position.Lexing.pos_bol)

let _ = main ()
